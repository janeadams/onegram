"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapParams = mapParams;
exports.default = void 0;

var _reduce2 = _interopRequireDefault(require("lodash/reduce"));

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _isString2 = _interopRequireDefault(require("lodash/isString"));

var _set2 = _interopRequireDefault(require("lodash/set"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _react = _interopRequireWildcard(require("react"));

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _checkStatus = _interopRequireDefault(require("./check-status"));

var _parseJson = _interopRequireDefault(require("./parse-json"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const connect = fn => DecoratedComponent => {
  var _temp;

  return _temp = class FetchOnUpdateDecorator extends _react.Component {
    constructor(...args) {
      super(...args);

      _defineProperty(this, "state", {});

      _defineProperty(this, "timers", {});
    }

    componentDidMount() {
      if (this.props.disableFetch) return;
      const itemsToFetch = fn(this.props);

      if (itemsToFetch) {
        for (let key in itemsToFetch) {
          const item = itemsToFetch[key];
          this.processItem(key, item);
        }
      }
    }

    componentDidUpdate(prevProps) {
      if (this.props.disableFetch) return;
      const itemsToFetch = fn(this.props);

      if (itemsToFetch) {
        for (let key in itemsToFetch) {
          const item = itemsToFetch[key];
          const keys = (0, _get2.default)(item, "keys"); // if they didn't specify any keys, we effectively only run the fetch function once on init

          if (keys && keys.length) {
            const params = mapParams(keys, this.props);
            const prevParams = mapParams(keys, prevProps);

            if (!(0, _shallowequal.default)(params, prevParams)) {
              this.processItem(key, item);
            }
          }
        }
      }
    }

    componentWillUnMount() {
      for (let key in this.timers) {
        clearTimeout(this.timers[key]);
      }

      this.timers = {};
    }

    processItem(key, item) {
      if (!item) return;

      if ((0, _isFunction2.default)(item)) {
        this.createLazyFunc(key, item);
      } else {
        this.doFetch(key, item);
      }
    }

    createLazyFunc(key, lazyFn) {
      this.setState({
        [key]: (...args) => {
          const result = lazyFn(...args);

          if (result) {
            for (let subkey in result) {
              const item = result[subkey];
              this.processItem(subkey, item);
            }
          }
        }
      });
    }

    async doFetch(key, item) {
      let {
        url,
        onData,
        onComplete,
        bearerToken,
        reset
      } = item,
          opts = _objectWithoutProperties(item, ["url", "onData", "onComplete", "bearerToken", "reset"]);

      if (!url && (0, _isString2.default)(item)) {
        url = item;
      }

      let {
        headers
      } = opts,
          otherOpts = _objectWithoutProperties(opts, ["headers"]);

      headers = headers || {};

      if (!headers["Accept"]) {
        headers["Accept"] = "application/json";
      }

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "application/json";
      }

      if (bearerToken) {
        headers["Authorization"] = `Bearer ${bearerToken}`;
      }

      if (this.timers[key]) {
        // clear any pending reset
        clearTimeout(this.timers[key]);
        delete this.timers[key];
      }

      this.setState(prevState => ({
        [key]: {
          data: (0, _get2.default)(prevState, `${key}.data`),
          isFetching: true,
          isFetched: !!(0, _get2.default)(prevState, `${key}.isFetched`),
          // if this is first time we are fetching, need to set isFetched to a bool
          error: null
        }
      }));

      try {
        let response = await fetch(url, _objectSpread({}, otherOpts, {
          headers
        }));
        response = await (0, _checkStatus.default)(response);

        if (response.status != 204) {
          response = await (0, _parseJson.default)(response);

          if (onData) {
            response = onData(response);

            if (response.then) {
              response = await handleAsyncOnDatas(response);
            }
          }
        } else {
          // for 204 No Content, just return null data
          response = null;
        }

        this.setState({
          [key]: {
            data: response,
            isFetching: false,
            isFetched: true,
            error: null
          }
        }, () => {
          if (onComplete) {
            const data = (0, _reduce2.default)(Object.keys(this.state), (result, k) => _objectSpread({}, result, {
              [k]: (0, _get2.default)(this.state, `${k}.data`)
            }), {});
            const manipulatedData = onComplete(data);

            if (manipulatedData) {
              this.setState(prevState => (0, _reduce2.default)(Object.keys(manipulatedData), (result, k) => _objectSpread({}, result, {
                [k]: _objectSpread({}, (0, _get2.default)(prevState, k, {}), {
                  data: manipulatedData[k]
                })
              }), {}));
            }
          }
        });

        if (reset) {
          this.timers[key] = setTimeout(() => {
            // reset the state
            this.setState({
              [key]: {
                data: null,
                isFetching: false,
                isFetched: false,
                error: null
              }
            });
            delete this.timers[key];
          }, reset);
        }
      } catch (ex) {
        this.setState(prevState => ({
          [key]: {
            data: prevState[key].data,
            isFetching: false,
            isFetched: prevState[key].isFetched,
            error: ex
          }
        }));
      }
    }

    render() {
      return _react.default.createElement(DecoratedComponent, _extends({}, this.props, this.state));
    }

  }, _temp;
};

function mapParams(paramKeys, params) {
  const result = {};
  paramKeys.forEach(path => {
    const value = (0, _get2.default)(params, path); // move any nested paths to the root of the result
    // for the purpose of doing a shallow comparison

    path = path.replace(/\./g, "_");
    (0, _set2.default)(result, path, value);
  });
  return result;
}

const handleAsyncOnDatas = async response => {
  response = await response;

  if (response.then) {
    response = await handleAsyncOnDatas(response);
  }

  return response;
};

var _default = connect;
exports.default = _default;