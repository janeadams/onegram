"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = batchFetch;

var _forEach2 = _interopRequireDefault(require("lodash/forEach"));

var _keys2 = _interopRequireDefault(require("lodash/keys"));

var _chunk2 = _interopRequireDefault(require("lodash/chunk"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _checkStatus = _interopRequireDefault(require("./check-status"));

var _parseJson = _interopRequireDefault(require("./parse-json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function batchFetch(keyName, performFetch, {
  maxBatchSize = 10,
  timeout = 100
} = {}) {
  let queue = {};
  const getDebounced = (0, _debounce2.default)((...extra) => {
    const thingsToFetch = queue;
    queue = {};
    const chunks = (0, _chunk2.default)((0, _keys2.default)(thingsToFetch), maxBatchSize);
    const allChunks = chunks.map(chunk => performFetch(chunk, ...extra).then(_checkStatus.default).then(_parseJson.default).then(items => {
      if (chunk.length == 1) {
        items = [items];
      }

      items.forEach(item => {
        const key = (0, _get2.default)(item, keyName);
        thingsToFetch[key].resolve(item);
        delete thingsToFetch[key];
      });
    }, err => {
      (0, _forEach2.default)(chunk, key => {
        thingsToFetch[key].reject(err);
        delete thingsToFetch[key];
      });
    })); // once they are all done (success or failure), reject any leftovers

    Promise.all(allChunks).then(() => {
      (0, _forEach2.default)(thingsToFetch, ({
        reject
      }, key) => {
        const err = new Error(`Could not find '${key}' in batched results.`); // fake a 404 response to reject the leftovers with

        err.response = {
          status: 404,
          statusText: "Not Found"
        };
        reject(err);
      });
    });
  }, timeout);
  return function getBatch(key, ...extra) {
    let resolve = null;
    let reject = null;
    var promise = new Promise((rs, rj) => {
      resolve = rs;
      reject = rj;
    });
    queue[key] = {
      resolve,
      reject
    };
    getDebounced(...extra);
    return promise;
  };
}