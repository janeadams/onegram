import _reduce from "lodash/reduce";
import _isFunction from "lodash/isFunction";
import _isString from "lodash/isString";
import _set from "lodash/set";
import _get from "lodash/get";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { Component } from "react";
import shallowEqual from "shallowequal";
import checkStatus from "./check-status";
import parseJSON from "./parse-json";

const connect = fn => DecoratedComponent => {
  var _temp;

  return _temp = class FetchOnUpdateDecorator extends Component {
    constructor(...args) {
      super(...args);

      _defineProperty(this, "state", {});

      _defineProperty(this, "timers", {});
    }

    componentDidMount() {
      if (this.props.disableFetch) return;
      const itemsToFetch = fn(this.props);

      if (itemsToFetch) {
        for (let key in itemsToFetch) {
          const item = itemsToFetch[key];
          this.processItem(key, item);
        }
      }
    }

    componentDidUpdate(prevProps) {
      if (this.props.disableFetch) return;
      const itemsToFetch = fn(this.props);

      if (itemsToFetch) {
        for (let key in itemsToFetch) {
          const item = itemsToFetch[key];

          const keys = _get(item, "keys"); // if they didn't specify any keys, we effectively only run the fetch function once on init


          if (keys && keys.length) {
            const params = mapParams(keys, this.props);
            const prevParams = mapParams(keys, prevProps);

            if (!shallowEqual(params, prevParams)) {
              this.processItem(key, item);
            }
          }
        }
      }
    }

    componentWillUnMount() {
      for (let key in this.timers) {
        clearTimeout(this.timers[key]);
      }

      this.timers = {};
    }

    processItem(key, item) {
      if (!item) return;

      if (_isFunction(item)) {
        this.createLazyFunc(key, item);
      } else {
        this.doFetch(key, item);
      }
    }

    createLazyFunc(key, lazyFn) {
      this.setState({
        [key]: (...args) => {
          const result = lazyFn(...args);

          if (result) {
            for (let subkey in result) {
              const item = result[subkey];
              this.processItem(subkey, item);
            }
          }
        }
      });
    }

    async doFetch(key, item) {
      let {
        url,
        onData,
        onComplete,
        bearerToken,
        reset
      } = item,
          opts = _objectWithoutProperties(item, ["url", "onData", "onComplete", "bearerToken", "reset"]);

      if (!url && _isString(item)) {
        url = item;
      }

      let {
        headers
      } = opts,
          otherOpts = _objectWithoutProperties(opts, ["headers"]);

      headers = headers || {};

      if (!headers["Accept"]) {
        headers["Accept"] = "application/json";
      }

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "application/json";
      }

      if (bearerToken) {
        headers["Authorization"] = `Bearer ${bearerToken}`;
      }

      if (this.timers[key]) {
        // clear any pending reset
        clearTimeout(this.timers[key]);
        delete this.timers[key];
      }

      this.setState(prevState => ({
        [key]: {
          data: _get(prevState, `${key}.data`),
          isFetching: true,
          isFetched: !!_get(prevState, `${key}.isFetched`),
          // if this is first time we are fetching, need to set isFetched to a bool
          error: null
        }
      }));

      try {
        let response = await fetch(url, _objectSpread({}, otherOpts, {
          headers
        }));
        response = await checkStatus(response);

        if (response.status != 204) {
          response = await parseJSON(response);

          if (onData) {
            response = onData(response);

            if (response.then) {
              response = await handleAsyncOnDatas(response);
            }
          }
        } else {
          // for 204 No Content, just return null data
          response = null;
        }

        this.setState({
          [key]: {
            data: response,
            isFetching: false,
            isFetched: true,
            error: null
          }
        }, () => {
          if (onComplete) {
            const data = _reduce(Object.keys(this.state), (result, k) => _objectSpread({}, result, {
              [k]: _get(this.state, `${k}.data`)
            }), {});

            const manipulatedData = onComplete(data);

            if (manipulatedData) {
              this.setState(prevState => _reduce(Object.keys(manipulatedData), (result, k) => _objectSpread({}, result, {
                [k]: _objectSpread({}, _get(prevState, k, {}), {
                  data: manipulatedData[k]
                })
              }), {}));
            }
          }
        });

        if (reset) {
          this.timers[key] = setTimeout(() => {
            // reset the state
            this.setState({
              [key]: {
                data: null,
                isFetching: false,
                isFetched: false,
                error: null
              }
            });
            delete this.timers[key];
          }, reset);
        }
      } catch (ex) {
        this.setState(prevState => ({
          [key]: {
            data: prevState[key].data,
            isFetching: false,
            isFetched: prevState[key].isFetched,
            error: ex
          }
        }));
      }
    }

    render() {
      return React.createElement(DecoratedComponent, _extends({}, this.props, this.state));
    }

  }, _temp;
};

export function mapParams(paramKeys, params) {
  const result = {};
  paramKeys.forEach(path => {
    const value = _get(params, path); // move any nested paths to the root of the result
    // for the purpose of doing a shallow comparison


    path = path.replace(/\./g, "_");

    _set(result, path, value);
  });
  return result;
}

const handleAsyncOnDatas = async response => {
  response = await response;

  if (response.then) {
    response = await handleAsyncOnDatas(response);
  }

  return response;
};

export default connect;