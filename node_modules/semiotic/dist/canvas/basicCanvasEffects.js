"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chuckCloseCanvasTransform = function (canvas, context, size, pixelSize) {
    if (pixelSize === void 0) { pixelSize = 10; }
    var _a = __read(size, 2), baseWidth = _a[0], baseHeight = _a[1];
    var height = baseHeight +
        (baseHeight % pixelSize === 0 ? 0 : pixelSize - (baseHeight % pixelSize));
    var width = baseWidth +
        (baseWidth % pixelSize === 0 ? 0 : pixelSize - (baseWidth % pixelSize));
    var rgbStep = 4 * pixelSize;
    var imageData = context.getImageData(0, 0, width, height);
    var rgbaArray = [];
    var imageArray = imageData.data;
    var rgbWidth = width * 4;
    var halfPixelSize = pixelSize / 2;
    for (var i = 0; i < imageArray.length; i += rgbStep) {
        var pixelPoint = {};
        if (pixelSize === 1) {
            pixelPoint = {
                r: imageArray[i],
                g: imageArray[i + 1],
                b: imageArray[i + 2],
                a: imageArray[i + 3],
                x: (i / 4) % width,
                y: Math.floor(i / 4 / width)
            };
        }
        else {
            var rgbHash = {};
            var totalHash = 0;
            for (var p = 0; p < pixelSize * 4; p += pixelSize * 4) {
                for (var q = 0; q < pixelSize * rgbWidth; q += rgbWidth) {
                    if (imageArray[p + i + q + 3] !== -1) {
                        var hashVal = "rgba(" + imageArray[p + i + q] + "," + imageArray[p + i + q + 1] + "," + imageArray[p + i + q + 2] + "," + imageArray[p + i + q + 3] + ")";
                        rgbHash[hashVal] = rgbHash[hashVal] ? rgbHash[hashVal] + 1 : 1;
                        totalHash += 1;
                    }
                }
            }
            pixelPoint = {
                rgbEntries: Object.values(rgbHash).sort(function (a, b) { return b - a; }),
                totalEntries: totalHash,
                x: (i / 4) % width,
                y: Math.floor(i / 4 / width),
                rmod: pixelSize
            };
        }
        rgbaArray.push(pixelPoint);
        if (pixelSize !== 1 && (i + rgbStep) % rgbWidth === 0) {
            i += rgbWidth * (pixelSize - 1);
        }
    }
    var scale = 1;
    var r = scale / 2;
    context.clearRect(0, 0, width, height);
    var circleArc = 2 * Math.PI;
    rgbaArray.forEach(function (point) {
        var currentR = r * pixelSize;
        var rStep = currentR / point.totalEntries;
        var baseX = point.x * scale + halfPixelSize;
        var baseY = point.y * scale + halfPixelSize;
        point.rgbEntries.forEach(function (e) {
            context.fillStyle = e[0];
            context.beginPath();
            context.arc(baseX, baseY, currentR, 0, circleArc);
            context.fill();
            currentR -= e[1] * rStep;
        });
    });
};
//# sourceMappingURL=basicCanvasEffects.js.map