"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var d3_hierarchy_1 = require("d3-hierarchy");
function recursiveIDAccessor(idAccessor, node, accessorString) {
    if (node.parent) {
        accessorString = accessorString + "-" + recursiveIDAccessor(idAccessor, __assign({}, node.parent, node.parent.data), accessorString);
    }
    return accessorString + "-" + idAccessor(__assign({}, node, node.data));
}
exports.nodesEdgesFromHierarchy = function (baseRootNode, idAccessor) {
    if (idAccessor === void 0) { idAccessor = function (d) { return d.id || d.descendantIndex; }; }
    var edges = [];
    var nodes = [];
    var rootNode = baseRootNode.descendants
        ? baseRootNode
        : d3_hierarchy_1.hierarchy(baseRootNode);
    var descendants = rootNode.descendants();
    descendants.forEach(function (d, i) {
        d.descendantIndex = i;
    });
    descendants.forEach(function (node, i) {
        var generatedID = idAccessor(__assign({}, node, node.data)) + "-" + ((node.parent &&
            recursiveIDAccessor(idAccessor, __assign({}, node.parent, node.parent.data), "")) ||
            "root");
        var dataD = Object.assign(node, node.data || {}, {
            hierarchicalID: generatedID
        });
        nodes.push(dataD);
        if (node.parent !== null) {
            var dataParent = Object.assign(node.parent, node.parent.data || {});
            edges.push({
                source: dataParent,
                target: dataD,
                depth: node.depth,
                weight: 1,
                value: 1,
                _NWFEdgeKey: generatedID
            });
        }
    });
    return { edges: edges, nodes: nodes };
};
//# sourceMappingURL=network.js.map