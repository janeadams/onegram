"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
// modules
var React = require("react");
//import { load } from 'opentype.js'
var annotationHandling_1 = require("./annotationLayerBehavior/annotationHandling");
var Legend_1 = require("./Legend");
var Annotation_1 = require("./Annotation");
var labella_1 = require("labella");
var SpanOrDiv_1 = require("./SpanOrDiv");
function marginOffsetFn(orient, axisSettings, marginOffset) {
    if (typeof marginOffset === "number") {
        return marginOffset;
    }
    if (axisSettings && axisSettings.find(function (d) { return d.props.orient === orient; })) {
        return 50;
    }
    return 10;
}
function adjustedAnnotationKeyMapper(d) {
    return d.props.noteData.id || d.props.noteData.x + "-" + d.props.noteData.y;
}
function noteDataWidth(noteData, charWidth) {
    if (charWidth === void 0) { charWidth = 8; }
    var wrap = (noteData.note && noteData.note.wrap) || 120;
    var noteText = noteData.note.label || noteData.note.label || "";
    return Math.min(wrap, noteText.length * charWidth);
}
function noteDataHeight(noteData, charWidth, lineHeight) {
    if (charWidth === void 0) { charWidth = 8; }
    if (lineHeight === void 0) { lineHeight = 20; }
    var wrap = (noteData.note && noteData.note.wrap) || 120;
    var text = noteData.note.label || noteData.note.title || "";
    return (Math.ceil((text.length * charWidth) / wrap) * lineHeight +
        (noteData.note.label && noteData.note.title ? lineHeight : 0));
}
var AnnotationLayer = /** @class */ (function (_super) {
    __extends(AnnotationLayer, _super);
    function AnnotationLayer(props) {
        var _this = _super.call(this, props) || this;
        /*    componentWillMount() {
            const fontLocation = this.props.fontLocation
      
            if (fontLocation) {
              load(fontLocation, function(err, font) {
                  if (err) {
                      return null
                  } else {
                      this.setState({ font });
                  }
              });
            }
          } */
        _this.generateSVGAnnotations = function (props, annotations) {
            var renderedAnnotations = annotations
                .map(function (d, i) { return props.svgAnnotationRule(d, i, props); })
                .filter(function (d) { return d !== null && d !== undefined; });
            return renderedAnnotations;
        };
        _this.generateHTMLAnnotations = function (props, annotations) {
            var renderedAnnotations = annotations
                .map(function (d, i) { return props.htmlAnnotationRule(d, i, props); })
                .filter(function (d) { return d !== null && d !== undefined; });
            return renderedAnnotations;
        };
        _this.processAnnotations = function (adjustableAnnotations, annotationProcessor, props) {
            var _a = annotationProcessor.layout, layout = _a === void 0 ? { type: false } : _a;
            if (layout.type === false) {
                return adjustableAnnotations;
            }
            var _b = props.margin, margin = _b === void 0 ? { top: 0, bottom: 0, left: 0, right: 0 } : _b;
            var size = props.size, _c = props.axes, axes = _c === void 0 ? [] : _c;
            margin =
                typeof margin === "number"
                    ? { top: margin, left: margin, right: margin, bottom: margin }
                    : margin;
            if (layout.type === "bump") {
                var adjustedAnnotations = annotationHandling_1.bumpAnnotations(adjustableAnnotations, layout, size, props.pointSizeFunction, props.labelSizeFunction);
                return adjustedAnnotations;
            }
            else if (layout.type === "marginalia") {
                var marginOffset_1 = layout.marginOffset, _d = layout.orient, orient = _d === void 0 ? "nearest" : _d, _e = layout.characterWidth, characterWidth_1 = _e === void 0 ? 8 : _e, _f = layout.lineHeight, lineHeight_1 = _f === void 0 ? 20 : _f, _g = layout.padding, padding_1 = _g === void 0 ? 2 : _g, _h = layout.axisMarginOverride, axisMarginOverride = _h === void 0 ? null : _h;
                var finalOrientation = orient === "nearest"
                    ? ["left", "right", "top", "bottom"]
                    : Array.isArray(orient)
                        ? orient
                        : [orient];
                var finalAxisMarginOverride = __assign({ top: null, right: null, bottom: null, left: null }, axisMarginOverride);
                var leftOn_1 = finalOrientation.find(function (d) { return d === "left"; });
                var rightOn_1 = finalOrientation.find(function (d) { return d === "right"; });
                var topOn_1 = finalOrientation.find(function (d) { return d === "top"; });
                var bottomOn_1 = finalOrientation.find(function (d) { return d === "bottom"; });
                var leftNodes_1 = [];
                var rightNodes_1 = [];
                var topNodes_1 = [];
                var bottomNodes_1 = [];
                adjustableAnnotations.forEach(function (aNote) {
                    var noteData = aNote.props.noteData;
                    var noteX = noteData.x[0] || noteData.x;
                    var noteY = noteData.y[0] || noteData.y;
                    var leftDist = leftOn_1 ? noteX : Infinity;
                    var rightDist = rightOn_1 ? size[0] - noteX : Infinity;
                    var topDist = topOn_1 ? noteY : Infinity;
                    var bottomDist = bottomOn_1 ? size[1] - noteY : Infinity;
                    var minDist = Math.min(leftDist, rightDist, topDist, bottomDist);
                    if (leftDist === minDist) {
                        leftNodes_1.push(aNote);
                    }
                    else if (rightDist === minDist) {
                        rightNodes_1.push(aNote);
                    }
                    else if (topDist === minDist) {
                        topNodes_1.push(aNote);
                    }
                    else {
                        bottomNodes_1.push(aNote);
                    }
                });
                //Adjust the margins based on which regions are active
                var leftForce = new labella_1.default.Force({
                    minPos: finalAxisMarginOverride.top
                        ? 0 + finalAxisMarginOverride.top
                        : 0 - margin.top,
                    maxPos: finalAxisMarginOverride.bottom
                        ? size[1] - finalAxisMarginOverride.bottom
                        : bottomOn_1
                            ? size[1]
                            : size[1] + margin.bottom
                })
                    .nodes(leftNodes_1.map(function (d) {
                    var noteY = d.props.noteData.y[0] || d.props.noteData.y;
                    return new labella_1.default.Node(noteY, noteDataHeight(d.props.noteData, characterWidth_1, lineHeight_1) +
                        padding_1);
                }))
                    .compute();
                var rightForce = new labella_1.default.Force({
                    minPos: finalAxisMarginOverride.top
                        ? 0 + finalAxisMarginOverride.top
                        : topOn_1
                            ? 0
                            : 0 - margin.top,
                    maxPos: finalAxisMarginOverride.bottom
                        ? size[1] - finalAxisMarginOverride.bottom
                        : size[1] + margin.bottom
                })
                    .nodes(rightNodes_1.map(function (d) {
                    var noteY = d.props.noteData.y[0] || d.props.noteData.y;
                    return new labella_1.default.Node(noteY, noteDataHeight(d.props.noteData, characterWidth_1, lineHeight_1) +
                        padding_1);
                }))
                    .compute();
                var topForce = new labella_1.default.Force({
                    minPos: finalAxisMarginOverride.left
                        ? 0 + finalAxisMarginOverride.left
                        : leftOn_1
                            ? 0
                            : 0 - margin.left,
                    maxPos: finalAxisMarginOverride.right
                        ? size[0] - finalAxisMarginOverride.right
                        : size[0] + margin.right
                })
                    .nodes(topNodes_1.map(function (d) {
                    var noteX = d.props.noteData.x[0] || d.props.noteData.x;
                    return new labella_1.default.Node(noteX, noteDataWidth(d.props.noteData, characterWidth_1) + padding_1);
                }))
                    .compute();
                var bottomForce = new labella_1.default.Force({
                    minPos: finalAxisMarginOverride.left
                        ? 0 + finalAxisMarginOverride.left
                        : 0 - margin.left,
                    maxPos: finalAxisMarginOverride.right
                        ? size[0] - finalAxisMarginOverride.right
                        : rightOn_1
                            ? size[0]
                            : size[0] + margin.right
                })
                    .nodes(bottomNodes_1.map(function (d) {
                    var noteX = d.props.noteData.x[0] || d.props.noteData.x;
                    return new labella_1.default.Node(noteX, noteDataWidth(d.props.noteData, characterWidth_1) + padding_1);
                }))
                    .compute();
                var bottomOffset_1 = Math.max.apply(Math, __spread(bottomNodes_1.map(function (d) {
                    return noteDataHeight(d.props.noteData, characterWidth_1, lineHeight_1) +
                        padding_1;
                })));
                var topOffset_1 = Math.max.apply(Math, __spread(topNodes_1.map(function (d) {
                    return noteDataHeight(d.props.noteData, characterWidth_1, lineHeight_1) +
                        padding_1;
                })));
                var leftOffset_1 = Math.max.apply(Math, __spread(leftNodes_1.map(function (d) { return noteDataWidth(d.props.noteData, characterWidth_1) + padding_1; })));
                var rightOffset_1 = Math.max.apply(Math, __spread(rightNodes_1.map(function (d) { return noteDataWidth(d.props.noteData, characterWidth_1) + padding_1; })));
                //      const nodeOffsetHeight = Math.max()
                var leftSortedNodes_1 = leftForce.nodes();
                var rightSortedNodes_1 = rightForce.nodes();
                var topSortedNodes_1 = topForce.nodes();
                var bottomSortedNodes_1 = bottomForce.nodes();
                leftNodes_1.forEach(function (note, i) {
                    note.props.noteData.ny = leftSortedNodes_1[i].currentPos;
                    note.props.noteData.nx =
                        0 -
                            leftSortedNodes_1[i].layerIndex * leftOffset_1 -
                            marginOffsetFn("left", axes, marginOffset_1);
                    if (note.props.noteData.note) {
                        note.props.noteData.note.orientation =
                            note.props.noteData.note.orientation || "leftRight";
                        note.props.noteData.note.align =
                            note.props.noteData.note.align || "right";
                    }
                });
                rightNodes_1.forEach(function (note, i) {
                    note.props.noteData.ny = rightSortedNodes_1[i].currentPos;
                    note.props.noteData.nx =
                        size[0] +
                            rightSortedNodes_1[i].layerIndex * rightOffset_1 +
                            marginOffsetFn("right", axes, marginOffset_1);
                    if (note.props.noteData.note) {
                        note.props.noteData.note.orientation =
                            note.props.noteData.note.orientation || "leftRight";
                        note.props.noteData.note.align =
                            note.props.noteData.note.align || "left";
                    }
                });
                topNodes_1.forEach(function (note, i) {
                    note.props.noteData.nx = topSortedNodes_1[i].currentPos;
                    note.props.noteData.ny =
                        0 -
                            topSortedNodes_1[i].layerIndex * topOffset_1 -
                            marginOffsetFn("top", axes, marginOffset_1);
                });
                bottomNodes_1.forEach(function (note, i) {
                    note.props.noteData.nx = bottomSortedNodes_1[i].currentPos;
                    note.props.noteData.ny =
                        size[1] +
                            bottomSortedNodes_1[i].layerIndex * bottomOffset_1 +
                            marginOffsetFn("bottom", axes, marginOffset_1);
                });
                return adjustableAnnotations;
            }
            return adjustableAnnotations;
        };
        _this.createAnnotations = function (props) {
            var renderedSVGAnnotations = _this.state.svgAnnotations, renderedHTMLAnnotations = [], adjustedAnnotations = _this.state.adjustedAnnotations, adjustableAnnotationsKey = _this.state.adjustedAnnotationsKey;
            var adjustedAnnotationsKey = _this.state.adjustedAnnotationsKey, adjustedAnnotationsDataVersion = _this.state.adjustedAnnotationsDataVersion;
            var annotations = props.annotations, _a = props.annotationHandling, annotationHandling = _a === void 0 ? false : _a, size = props.size, svgAnnotationRule = props.svgAnnotationRule, htmlAnnotationRule = props.htmlAnnotationRule;
            var annotationProcessor = typeof annotationHandling === "object"
                ? annotationHandling
                : { layout: { type: annotationHandling }, dataVersion: "" };
            var _b = annotationProcessor.dataVersion, dataVersion = _b === void 0 ? "" : _b;
            if (svgAnnotationRule) {
                var initialSVGAnnotations = _this.generateSVGAnnotations(props, annotations);
                var adjustableAnnotations_1 = initialSVGAnnotations.filter(function (d) { return d.props && d.props.noteData && !d.props.noteData.fixedPosition; });
                var fixedAnnotations = initialSVGAnnotations.filter(function (d) { return !d.props || !d.props.noteData || d.props.noteData.fixedPosition; });
                adjustableAnnotationsKey = "" + adjustableAnnotations_1
                    .map(adjustedAnnotationKeyMapper)
                    .join(",") + JSON.stringify(annotationProcessor) + size.join(",");
                if (annotationHandling === false) {
                    adjustedAnnotations = adjustableAnnotations_1;
                }
                if (adjustedAnnotations.length !== adjustableAnnotations_1.length ||
                    adjustedAnnotationsKey !== adjustableAnnotationsKey ||
                    adjustedAnnotationsDataVersion !== dataVersion) {
                    adjustedAnnotations = _this.processAnnotations(adjustableAnnotations_1, annotationProcessor, props);
                }
                else {
                    //Handle when style or other attributes change
                    adjustedAnnotations = adjustedAnnotations.map(function (d, i) {
                        var newNoteData = Object.assign(adjustableAnnotations_1[i].props.noteData, {
                            nx: d.props.noteData.nx,
                            ny: d.props.noteData.ny,
                            note: d.props.noteData.note
                        });
                        return React.createElement(Annotation_1.default, { key: d.key, noteData: newNoteData });
                    });
                }
                renderedSVGAnnotations = __spread(adjustedAnnotations, fixedAnnotations);
            }
            if (htmlAnnotationRule) {
                renderedHTMLAnnotations = _this.generateHTMLAnnotations(props, annotations);
            }
            _this.setState({
                svgAnnotations: renderedSVGAnnotations,
                htmlAnnotations: renderedHTMLAnnotations,
                adjustedAnnotations: adjustedAnnotations,
                adjustedAnnotationsKey: adjustableAnnotationsKey,
                adjustedAnnotationsDataVersion: dataVersion
            });
        };
        _this.state = {
            svgAnnotations: [],
            htmlAnnotations: [],
            adjustedAnnotations: [],
            adjustedAnnotationsKey: "",
            adjustedAnnotationsDataVersion: ""
        };
        return _this;
    }
    AnnotationLayer.prototype.componentWillMount = function () {
        this.createAnnotations(this.props);
    };
    AnnotationLayer.prototype.componentWillReceiveProps = function (nextProps) {
        this.createAnnotations(nextProps);
    };
    AnnotationLayer.prototype.render = function () {
        var _a = this.state, svgAnnotations = _a.svgAnnotations, htmlAnnotations = _a.htmlAnnotations;
        var _b = this.props, useSpans = _b.useSpans, legendSettings = _b.legendSettings, margin = _b.margin, size = _b.size;
        var renderedLegend;
        if (legendSettings) {
            var positionHash = {
                left: [15, 15],
                right: [size[0] + 15, 15]
            };
            var _c = legendSettings.position, position = _c === void 0 ? "right" : _c, _d = legendSettings.title, title = _d === void 0 ? "Legend" : _d;
            var legendPosition = positionHash[position];
            renderedLegend = (React.createElement("g", { transform: "translate(" + legendPosition.join(",") + ")" },
                React.createElement(Legend_1.default, __assign({}, legendSettings, { title: title, position: position }))));
        }
        return (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "annotation-layer", style: {
                position: "absolute",
                pointerEvents: "none",
                background: "none"
            } },
            React.createElement("svg", { className: "annotation-layer-svg", height: size[1], width: size[0], style: {
                    background: "none",
                    pointerEvents: "none",
                    position: "absolute",
                    left: margin.left + "px",
                    top: margin.top + "px",
                    overflow: "visible"
                } },
                React.createElement("g", null,
                    renderedLegend,
                    svgAnnotations)),
            React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "annotation-layer-html", style: {
                    background: "none",
                    pointerEvents: "none",
                    position: "absolute",
                    height: size[1] + "px",
                    width: size[0] + "px",
                    left: margin.left + "px",
                    top: margin.top + "px"
                } }, htmlAnnotations)));
    };
    return AnnotationLayer;
}(React.Component));
exports.default = AnnotationLayer;
//# sourceMappingURL=AnnotationLayer.js.map