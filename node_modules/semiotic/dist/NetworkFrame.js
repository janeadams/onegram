"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var d3_force_1 = require("d3-force");
var d3_bboxCollide_1 = require("d3-bboxCollide");
var d3_scale_1 = require("d3-scale");
var d3_array_1 = require("d3-array");
var AnnotationLabel_1 = require("react-annotation/lib/Types/AnnotationLabel");
var Frame_1 = require("./Frame");
var DownloadButton_1 = require("./DownloadButton");
var frameFunctions_1 = require("./svg/frameFunctions");
var pieceDrawing_1 = require("./svg/pieceDrawing");
var networkDrawing_1 = require("./svg/networkDrawing");
var dataFunctions_1 = require("./data/dataFunctions");
var downloadDataMapping_1 = require("./downloadDataMapping");
var d3_sankey_circular_1 = require("d3-sankey-circular");
var d3_chord_1 = require("d3-chord");
var d3_shape_1 = require("d3-shape");
var d3_hierarchy_1 = require("d3-hierarchy");
var frame_props_1 = require("./constants/frame_props");
var networkframeRules_1 = require("./annotationRules/networkframeRules");
var baseRules_1 = require("./annotationRules/baseRules");
var functions_1 = require("./untyped_utilities/functions");
var svg_path_bounding_box_1 = require("svg-path-bounding-box");
var network_1 = require("./processing/network");
var emptyArray = [];
var matrixRenderOrder = ["nodes", "edges"];
var generalRenderOrder = ["edges", "nodes"];
var baseNodeProps = {
    id: undefined,
    degree: 0,
    inDegree: 0,
    outDegree: 0,
    x: 0,
    y: 0,
    x1: 0,
    x0: 0,
    y1: 0,
    y0: 0,
    height: 0,
    width: 0,
    radius: 0,
    r: 0,
    direction: undefined,
    textHeight: 0,
    textWidth: 0,
    fontSize: 0,
    scale: 1,
    nodeSize: 0,
    component: -99,
    shapeNode: false
};
var baseNetworkSettings = {
    iterations: 500,
    hierarchicalNetwork: false
};
var baseGraphSettings = {
    nodeHash: new Map(),
    edgeHash: new Map(),
    nodes: [],
    edges: [],
    hierarchicalNetwork: false,
    type: "force"
};
var basicMiddle = function (d) { return ({
    edge: d,
    x: (d.source.x + d.target.x) / 2,
    y: (d.source.y + d.target.y) / 2
}); };
var edgePointHash = {
    sankey: function (d) { return ({
        edge: d,
        x: (d.source.x1 + d.target.x0) / 2,
        y: d.circularPathData
            ? d.circularPathData.verticalFullExtent
            : ((d.y0 + d.y1) / 2 + (d.y0 + d.y1) / 2) / 2
    }); },
    force: basicMiddle,
    tree: basicMiddle,
    cluster: basicMiddle
};
var hierarchicalTypeHash = {
    dendrogram: d3_hierarchy_1.tree,
    tree: d3_hierarchy_1.tree,
    circlepack: d3_hierarchy_1.pack,
    cluster: d3_hierarchy_1.cluster,
    treemap: d3_hierarchy_1.treemap,
    partition: d3_hierarchy_1.partition
};
var hierarchicalProjectable = {
    partition: true,
    cluster: true,
    tree: true,
    dendrogram: true
};
var radialProjectable = {
    partition: true,
    cluster: true,
    tree: true,
    dendrogram: true
};
/*
const customEdgeHashProject = {
  offset: glyphProject.offset,
  parallel: glyphProject.parallel
}

const customEdgeHashMutate = {
  particle: glyphMutate.particle
}
*/
function determineNodeIcon(baseCustomNodeIcon, networkSettings, size, nodes) {
    if (baseCustomNodeIcon)
        return baseCustomNodeIcon;
    var center = [size[0] / 2, size[1] / 2];
    switch (networkSettings.type) {
        case "sankey":
            return networkDrawing_1.sankeyNodeGenerator;
        case "partition":
            return networkSettings.projection === "radial"
                ? networkDrawing_1.radialRectNodeGenerator(size, center, networkSettings)
                : networkDrawing_1.hierarchicalRectNodeGenerator;
        case "treemap":
            return networkSettings.projection === "radial"
                ? networkDrawing_1.radialRectNodeGenerator(size, center, networkSettings)
                : networkDrawing_1.hierarchicalRectNodeGenerator;
        case "circlepack":
            return networkDrawing_1.circleNodeGenerator;
        case "wordcloud":
            return networkDrawing_1.wordcloudNodeGenerator;
        case "chord":
            return networkDrawing_1.chordNodeGenerator(size);
        case "dagre":
            return networkDrawing_1.hierarchicalRectNodeGenerator;
        case "matrix":
            return networkDrawing_1.matrixNodeGenerator(size, nodes);
    }
    return networkDrawing_1.circleNodeGenerator;
}
function determineEdgeIcon(_a) {
    var baseCustomEdgeIcon = _a.baseCustomEdgeIcon, networkSettings = _a.networkSettings, size = _a.size, graph = _a.graph, nodes = _a.nodes;
    if (baseCustomEdgeIcon)
        return baseCustomEdgeIcon;
    switch (networkSettings.type) {
        case "partition":
            return function () { return null; };
        case "treemap":
            return function () { return null; };
        case "circlepack":
            return function () { return null; };
        case "wordcloud":
            return function () { return null; };
        case "chord":
            return networkDrawing_1.chordEdgeGenerator(size);
        case "matrix":
            return networkDrawing_1.matrixEdgeGenerator(size, nodes);
        case "arc":
            return networkDrawing_1.arcEdgeGenerator(size);
        case "dagre":
            if (graph)
                return networkDrawing_1.dagreEdgeGenerator(graph.graph().rankdir);
    }
    return undefined;
}
function breadthFirstCompontents(baseNodes, hash) {
    var componentHash = {
        "0": { componentNodes: [], componentEdges: [] }
    };
    var components = [componentHash["0"]];
    var componentID = 0;
    traverseNodesBF(baseNodes, true);
    function traverseNodesBF(nodes, top) {
        nodes.forEach(function (node) {
            var _a;
            var hashNode = hash.get(node);
            if (!hashNode) {
                componentHash["0"].componentNodes.push(node);
            }
            else if (hashNode.component === -99) {
                if (top === true) {
                    componentID++;
                    componentHash[componentID] = {
                        componentNodes: [],
                        componentEdges: []
                    };
                    components.push(componentHash[componentID]);
                }
                hashNode.component = componentID;
                componentHash[componentID].componentNodes.push(node);
                (_a = componentHash[componentID].componentEdges).push.apply(_a, __spread(hashNode.edges));
                var traversibleNodes = __spread(hashNode.connectedNodes);
                traverseNodesBF(traversibleNodes, hash);
            }
        });
    }
    return components.sort(function (a, b) { return b.componentNodes.length - a.componentNodes.length; });
}
var projectedCoordinateNames = { y: "y", x: "x" };
var sankeyOrientHash = {
    left: d3_sankey_circular_1.sankeyLeft,
    right: d3_sankey_circular_1.sankeyRight,
    center: d3_sankey_circular_1.sankeyCenter,
    justify: d3_sankey_circular_1.sankeyJustify
};
var xScale = d3_scale_1.scaleLinear();
var yScale = d3_scale_1.scaleLinear();
var matrixify = function (_a) {
    var edgeHash = _a.edgeHash, nodes = _a.nodes, edgeWidthAccessor = _a.edgeWidthAccessor, nodeIDAccessor = _a.nodeIDAccessor;
    var matrix = [];
    nodes.forEach(function (nodeSource) {
        var nodeSourceID = nodeIDAccessor(nodeSource);
        var sourceRow = [];
        matrix.push(sourceRow);
        nodes.forEach(function (nodeTarget) {
            var nodeTargetID = nodeIDAccessor(nodeTarget);
            var theEdge = edgeHash.get(nodeSourceID + "|" + nodeTargetID);
            if (theEdge) {
                sourceRow.push(edgeWidthAccessor(theEdge));
            }
            else {
                sourceRow.push(0);
            }
        });
    });
    return matrix;
};
var NetworkFrame = /** @class */ (function (_super) {
    __extends(NetworkFrame, _super);
    function NetworkFrame(props) {
        var _this = _super.call(this, props) || this;
        _this.defaultNetworkSVGRule = function (_a) {
            var baseD = _a.d, i = _a.i, annotationLayer = _a.annotationLayer;
            var _b = _this.state, projectedNodes = _b.projectedNodes, projectedEdges = _b.projectedEdges, nodeIDAccessor = _b.nodeIDAccessor, nodeSizeAccessor = _b.nodeSizeAccessor, networkFrameRender = _b.networkFrameRender, adjustedSize = _b.adjustedSize, adjustedPosition = _b.adjustedPosition;
            //TODO PASS FRAME STYLE FNs TO HIGHLIGHT
            var svgAnnotationRules = _this.props.svgAnnotationRules;
            var d = baseD.ids
                ? baseD
                : baseD.edge
                    ? __assign({}, (projectedEdges.find(function (p) {
                        return nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) &&
                            nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target);
                    }) || {}), baseD) : __assign({}, (projectedNodes.find(function (p) { return nodeIDAccessor(p) === baseD.id; }) || {}), baseD);
            var voronoiHover = annotationLayer.voronoiHover;
            if (svgAnnotationRules) {
                var customAnnotation = svgAnnotationRules({
                    d: d,
                    i: i,
                    networkFrameProps: _this.props,
                    networkFrameState: _this.state,
                    nodes: projectedNodes,
                    edges: projectedEdges,
                    voronoiHover: voronoiHover,
                    screenCoordinates: [d.x, d.y],
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer
                });
                if (customAnnotation !== null) {
                    return customAnnotation;
                }
            }
            if (d.type === "node") {
                return networkframeRules_1.svgNodeRule({
                    d: d,
                    i: i,
                    nodeSizeAccessor: nodeSizeAccessor
                });
            }
            else if (d.type === "desaturation-layer") {
                return baseRules_1.desaturationLayer({
                    style: d.style instanceof Function ? d.style(d, i) : d.style,
                    size: adjustedSize,
                    i: i,
                    key: d.key
                });
            }
            else if (d.type === "basic-node-label") {
                return (React.createElement("g", { key: d.key || "basic-" + i, transform: "translate(" + d.x + "," + d.y + ")" }, baseD.element || baseD.label));
            }
            else if (d.type === "react-annotation" || typeof d.type === "function") {
                return networkframeRules_1.svgReactAnnotationRule({
                    d: d,
                    i: i,
                    projectedNodes: projectedNodes,
                    nodeIDAccessor: nodeIDAccessor
                });
            }
            else if (d.type === "enclose") {
                return networkframeRules_1.svgEncloseRule({
                    d: d,
                    i: i,
                    projectedNodes: projectedNodes,
                    nodeIDAccessor: nodeIDAccessor,
                    nodeSizeAccessor: nodeSizeAccessor
                });
            }
            else if (d.type === "enclose-rect") {
                return networkframeRules_1.svgRectEncloseRule({
                    d: d,
                    i: i,
                    projectedNodes: projectedNodes,
                    nodeIDAccessor: nodeIDAccessor,
                    nodeSizeAccessor: nodeSizeAccessor
                });
            }
            else if (d.type === "enclose-hull") {
                return networkframeRules_1.svgHullEncloseRule({
                    d: d,
                    i: i,
                    projectedNodes: projectedNodes,
                    nodeIDAccessor: nodeIDAccessor,
                    nodeSizeAccessor: nodeSizeAccessor
                });
            }
            else if (d.type === "highlight") {
                return networkframeRules_1.svgHighlightRule({
                    d: d,
                    networkFrameRender: networkFrameRender
                });
            }
            return null;
        };
        _this.defaultNetworkHTMLRule = function (_a) {
            var baseD = _a.d, i = _a.i, annotationLayer = _a.annotationLayer;
            var _b = _this.props, tooltipContent = _b.tooltipContent, size = _b.size, useSpans = _b.useSpans;
            var _c = _this.state, projectedNodes = _c.projectedNodes, projectedEdges = _c.projectedEdges, nodeIDAccessor = _c.nodeIDAccessor, adjustedSize = _c.adjustedSize, adjustedPosition = _c.adjustedPosition;
            var voronoiHover = annotationLayer.voronoiHover;
            var d = baseD.ids
                ? baseD
                : baseD.edge
                    ? __assign({}, (projectedEdges.find(function (p) {
                        return nodeIDAccessor(p.source) === nodeIDAccessor(baseD.source) &&
                            nodeIDAccessor(p.target) === nodeIDAccessor(baseD.target);
                    }) || {}), baseD) : __assign({}, (projectedNodes.find(function (p) { return nodeIDAccessor(p) === baseD.id; }) || {}), baseD);
            if (_this.props.htmlAnnotationRules) {
                var customAnnotation = _this.props.htmlAnnotationRules({
                    d: d,
                    i: i,
                    networkFrameProps: _this.props,
                    networkFrameState: _this.state,
                    nodes: projectedNodes,
                    edges: projectedEdges,
                    voronoiHover: voronoiHover,
                    screenCoordinates: [d.x, d.y],
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer
                });
                if (customAnnotation !== null) {
                    return customAnnotation;
                }
            }
            if (d.type === "frame-hover") {
                return networkframeRules_1.htmlFrameHoverRule({
                    d: d,
                    i: i,
                    tooltipContent: tooltipContent,
                    useSpans: useSpans,
                    nodes: projectedNodes,
                    edges: projectedEdges,
                    nodeIDAccessor: nodeIDAccessor
                });
            }
            return null;
        };
        _this.state = {
            dataVersion: undefined,
            nodeData: [],
            edgeData: [],
            adjustedPosition: [],
            adjustedSize: [],
            backgroundGraphics: null,
            foregroundGraphics: null,
            projectedNodes: [],
            projectedEdges: [],
            renderNumber: 0,
            nodeLabelAnnotations: [],
            graphSettings: {
                type: "empty-start",
                nodes: [],
                edges: [],
                nodeHash: new Map(),
                edgeHash: new Map(),
                hierarchicalNetwork: false
            },
            edgeWidthAccessor: dataFunctions_1.stringToFn("weight"),
            legendSettings: {},
            margin: { top: 0, left: 0, right: 0, bottom: 0 },
            networkFrameRender: {},
            nodeIDAccessor: dataFunctions_1.stringToFn("id"),
            nodeSizeAccessor: functions_1.genericFunction(5),
            overlay: [],
            projectedXYPoints: [],
            sourceAccessor: dataFunctions_1.stringToFn("source"),
            targetAccessor: dataFunctions_1.stringToFn("target"),
            title: { title: undefined }
        };
        return _this;
    }
    NetworkFrame.prototype.componentWillUnmount = function () {
        if (this.props.onUnmount) {
            this.props.onUnmount(this.props, this.state);
        }
    };
    NetworkFrame.prototype.componentWillMount = function () {
        Object.keys(this.props).forEach(function (d) {
            if (!frame_props_1.networkframeproptypes[d]) {
                if (frame_props_1.xyframeproptypes[d]) {
                    console.error(d + " is an XYFrame prop are you sure you're using the right frame?");
                }
                else if (frame_props_1.ordinalframeproptypes[d]) {
                    console.error(d + " is an OrdinalFrame prop are you sure you're using the right frame?");
                }
                else {
                    console.error(d + " is not a valid NetworkFrame prop");
                }
            }
        });
        this.calculateNetworkFrame(this.props);
    };
    NetworkFrame.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        if ((this.state.dataVersion &&
            this.state.dataVersion !== nextProps.dataVersion) ||
            (!this.state.projectedNodes && !this.state.projectedEdges)) {
            this.calculateNetworkFrame(nextProps);
        }
        else if (this.props.size[0] !== nextProps.size[0] ||
            this.props.size[1] !== nextProps.size[1] ||
            (!this.state.dataVersion &&
                frame_props_1.networkFrameChangeProps.find(function (d) {
                    return _this.props[d] !== nextProps[d];
                }))) {
            this.calculateNetworkFrame(nextProps);
        }
    };
    NetworkFrame.prototype.onNodeClick = function (d, i) {
        if (this.props.onNodeClick) {
            this.props.onNodeClick(d, i);
        }
    };
    NetworkFrame.prototype.onNodeEnter = function (d, i) {
        if (this.props.onNodeEnter) {
            this.props.onNodeEnter(d, i);
        }
    };
    NetworkFrame.prototype.onNodeOut = function (d, i) {
        if (this.props.onNodeOut) {
            this.props.onNodeOut(d, i);
        }
    };
    NetworkFrame.prototype.calculateNetworkFrame = function (currentProps) {
        var _this = this;
        var graph = currentProps.graph, _a = currentProps.nodes, nodes = _a === void 0 ? Array.isArray(graph) || typeof graph === "function"
            ? emptyArray
            : (graph && graph.nodes) || emptyArray : _a, _b = currentProps.edges, edges = _b === void 0 ? typeof graph === "function"
            ? emptyArray
            : Array.isArray(graph)
                ? graph
                : (graph && graph.edges) || emptyArray : _b, networkType = currentProps.networkType, size = currentProps.size, nodeStyle = currentProps.nodeStyle, nodeClass = currentProps.nodeClass, canvasNodes = currentProps.canvasNodes, edgeStyle = currentProps.edgeStyle, edgeClass = currentProps.edgeClass, canvasEdges = currentProps.canvasEdges, nodeRenderMode = currentProps.nodeRenderMode, edgeRenderMode = currentProps.edgeRenderMode, nodeLabels = currentProps.nodeLabels, baseTitle = currentProps.title, baseMargin = currentProps.margin, hoverAnnotation = currentProps.hoverAnnotation, baseCustomNodeIcon = currentProps.customNodeIcon, baseCustomEdgeIcon = currentProps.customEdgeIcon, filterRenderedNodes = currentProps.filterRenderedNodes;
        var edgeType = currentProps.edgeType;
        var networkSettings;
        var nodeHierarchicalIDFill = {};
        var networkSettingsKeys = ["type"];
        if (typeof networkType === "string") {
            networkSettings = __assign({ type: networkType }, baseNetworkSettings, { graphSettings: baseGraphSettings });
        }
        else {
            if (networkType)
                networkSettingsKeys = Object.keys(networkType);
            networkSettings = __assign({ type: "force" }, baseNetworkSettings, networkType, { graphSettings: baseGraphSettings });
        }
        if (networkSettings.projection === "vertical" &&
            networkSettings.type === "sankey") {
            networkSettings.direction = "down";
        }
        networkSettingsKeys.push("height", "width");
        var title = typeof baseTitle === "object" &&
            !React.isValidElement(baseTitle) &&
            baseTitle !== null
            ? baseTitle
            : { title: baseTitle, orient: "top" };
        var margin = frameFunctions_1.calculateMargin({
            margin: baseMargin,
            title: title
        });
        var _c = frameFunctions_1.adjustedPositionSize({
            size: size,
            margin: margin
        }), adjustedPosition = _c.adjustedPosition, adjustedSize = _c.adjustedSize;
        networkSettings.graphSettings.nodes = nodes;
        networkSettings.graphSettings.edges = edges;
        var _d = networkSettings.graphSettings, edgeHash = _d.edgeHash, nodeHash = _d.nodeHash;
        var createPointLayer = networkSettings.type === "treemap" ||
            networkSettings.type === "partition" ||
            networkSettings.type === "sankey";
        var nodeIDAccessor = dataFunctions_1.stringToFn(currentProps.nodeIDAccessor, function (d) { return d.id; });
        var sourceAccessor = dataFunctions_1.stringToFn(currentProps.sourceAccessor, function (d) { return d.source; });
        var targetAccessor = dataFunctions_1.stringToFn(currentProps.targetAccessor, function (d) { return d.target; });
        var nodeSizeAccessor = typeof currentProps.nodeSizeAccessor === "number"
            ? functions_1.genericFunction(currentProps.nodeSizeAccessor)
            : dataFunctions_1.stringToFn(currentProps.nodeSizeAccessor, function (d) { return d.r || 5; });
        var edgeWidthAccessor = dataFunctions_1.stringToFn(currentProps.edgeWidthAccessor, function (d) { return d.weight || 1; });
        var nodeStyleFn = dataFunctions_1.stringToFn(nodeStyle, function () { return ({}); }, true);
        var nodeClassFn = dataFunctions_1.stringToFn(nodeClass, function () { return ""; }, true);
        var nodeRenderModeFn = dataFunctions_1.stringToFn(nodeRenderMode, undefined, true);
        var nodeCanvasRenderFn = canvasNodes && dataFunctions_1.stringToFn(canvasNodes, undefined, true);
        var _e = this.state, projectedNodes = _e.projectedNodes, projectedEdges = _e.projectedEdges;
        var isHierarchical = typeof networkSettings.type === "string" &&
            hierarchicalTypeHash[networkSettings.type];
        var changedData = !this.state.projectedNodes ||
            !this.state.projectedEdges ||
            this.state.graphSettings.nodes !== nodes ||
            this.state.graphSettings.edges !== edges ||
            isHierarchical;
        if (networkSettings.type === "dagre") {
            var dagreGraph_1 = graph;
            var dagreNodeHash_1 = {};
            projectedNodes = dagreGraph_1.nodes().map(function (n) {
                var baseNode = dagreGraph_1.node(n);
                dagreNodeHash_1[n] = __assign({}, baseNode, { x0: baseNode.x - baseNode.width / 2, x1: baseNode.x + baseNode.width / 2, y0: baseNode.y - baseNode.height / 2, y1: baseNode.y + baseNode.height / 2, id: n, shapeNode: true, sourceLinks: [], targetLinks: [] });
                return dagreNodeHash_1[n];
            });
            projectedEdges = dagreGraph_1.edges().map(function (e) {
                var dagreEdge = dagreGraph_1.edge(e);
                var baseEdge = __assign({}, dagreEdge, { points: dagreEdge.points.map(function (d) { return (__assign({}, d)); }) });
                baseEdge.source = projectedNodes.find(function (p) { return p.id === e.v; });
                baseEdge.target = projectedNodes.find(function (p) { return p.id === e.w; });
                baseEdge.points.unshift({ x: baseEdge.source.x, y: baseEdge.source.y });
                baseEdge.points.push({ x: baseEdge.target.x, y: baseEdge.target.y });
                dagreNodeHash_1[e.v].targetLinks.push(baseEdge);
                dagreNodeHash_1[e.w].sourceLinks.push(baseEdge);
                return baseEdge;
            });
        }
        else if (changedData) {
            edgeHash = new Map();
            nodeHash = new Map();
            networkSettings.graphSettings.edgeHash = edgeHash;
            networkSettings.graphSettings.nodeHash = nodeHash;
            projectedNodes = [];
            projectedEdges = [];
            nodes.forEach(function (node) {
                var projectedNode = __assign({}, node);
                var id = nodeIDAccessor(projectedNode);
                nodeHash.set(id, projectedNode);
                nodeHash.set(node, projectedNode);
                projectedNodes.push(projectedNode);
                projectedNode.id = id;
                projectedNode.inDegree = 0;
                projectedNode.outDegree = 0;
                projectedNode.degree = 0;
            });
            var operationalEdges = edges;
            var baseEdges = edges;
            if (isHierarchical && Array.isArray(edges)) {
                var createdHierarchicalData = networkDrawing_1.softStack(edges, projectedNodes, sourceAccessor, targetAccessor, nodeIDAccessor);
                if (createdHierarchicalData.isHierarchical) {
                    baseEdges = createdHierarchicalData.hierarchy;
                    projectedNodes = [];
                }
                else {
                    console.error("You've sent an edge list that is not strictly hierarchical (there are nodes with multiple parents) defaulting to force-directed network layout");
                    networkSettings.type = "force";
                }
            }
            if (!Array.isArray(baseEdges)) {
                networkSettings.hierarchicalNetwork = true;
                var rootNode = d3_hierarchy_1.hierarchy(baseEdges, networkSettings.hierarchyChildren);
                rootNode.sum(networkSettings.hierarchySum || (function (d) { return d.value; }));
                if (isHierarchical) {
                    var layout = networkSettings.layout || isHierarchical;
                    var hierarchicalLayout_1 = layout();
                    var networkSettingKeys = Object.keys(networkSettings);
                    if ((networkSettings.type === "dendrogram" ||
                        networkSettings.type === "tree" ||
                        networkSettings.type === "cluster") &&
                        hierarchicalLayout_1.separation) {
                        hierarchicalLayout_1.separation(function (a, b) {
                            return (nodeSizeAccessor(__assign({}, a, a.data)) || 1) +
                                (networkSettings.nodePadding || 0) +
                                (nodeSizeAccessor(__assign({}, b, b.data)) || 1);
                        });
                    }
                    networkSettingKeys.forEach(function (key) {
                        if (hierarchicalLayout_1[key]) {
                            hierarchicalLayout_1[key](networkSettings[key]);
                        }
                    });
                    var layoutSize = networkSettings.projection === "horizontal" && isHierarchical
                        ? [adjustedSize[1], adjustedSize[0]]
                        : adjustedSize;
                    if (!networkSettings.nodeSize && hierarchicalLayout_1.size) {
                        hierarchicalLayout_1.size(layoutSize);
                    }
                    hierarchicalLayout_1(rootNode);
                }
                operationalEdges = network_1.nodesEdgesFromHierarchy(rootNode, nodeIDAccessor)
                    .edges;
            }
            baseNodeProps.shapeNode = createPointLayer;
            if (Array.isArray(operationalEdges)) {
                operationalEdges.forEach(function (edge) {
                    var source = sourceAccessor(edge);
                    var target = targetAccessor(edge);
                    var sourceTarget = [source, target];
                    sourceTarget.forEach(function (nodeDirection) {
                        if (!nodeHash.get(nodeDirection)) {
                            var nodeObject = typeof nodeDirection === "object"
                                ? __assign({}, baseNodeProps, nodeDirection) : __assign({}, baseNodeProps, { id: nodeDirection, createdByFrame: true });
                            var nodeIDValue = nodeObject.id || nodeIDAccessor(nodeObject);
                            nodeHierarchicalIDFill[nodeIDValue]
                                ? (nodeHierarchicalIDFill[nodeIDValue] += 1)
                                : (nodeHierarchicalIDFill[nodeIDValue] = 1);
                            if (!nodeObject.id) {
                                var nodeSuffix = nodeHierarchicalIDFill[nodeIDValue] === 1
                                    ? ""
                                    : "-" + nodeHierarchicalIDFill[nodeIDValue];
                                nodeObject.id = "" + nodeIDValue + nodeSuffix;
                            }
                            nodeHash.set(nodeDirection, nodeObject);
                            projectedNodes.push(nodeObject);
                        }
                    });
                    var edgeWeight = edge.weight || 1;
                    var sourceNode = nodeHash.get(source);
                    var targetNode = nodeHash.get(target);
                    targetNode.inDegree += edgeWeight;
                    sourceNode.outDegree += edgeWeight;
                    targetNode.degree += edgeWeight;
                    sourceNode.degree += edgeWeight;
                    var edgeKey = (nodeIDAccessor(sourceNode) ||
                        source) + "|" + (nodeIDAccessor(targetNode) || target);
                    var newEdge = Object.assign({}, edge, {
                        source: nodeHash.get(source),
                        target: nodeHash.get(target)
                    });
                    edgeHash.set(edgeKey, newEdge);
                    projectedEdges.push(newEdge);
                });
            }
        }
        else {
            edgeHash = new Map();
            networkSettings.graphSettings.edgeHash = edgeHash;
            projectedEdges.forEach(function (edge) {
                var edgeSource = typeof edge.source === "string"
                    ? edge.source
                    : nodeIDAccessor(edge.source);
                var edgeTarget = typeof edge.target === "string"
                    ? edge.target
                    : nodeIDAccessor(edge.target);
                var edgeKey = edgeSource + "|" + edgeTarget;
                edgeHash.set(edgeKey, edge);
            });
        }
        var customNodeIcon = determineNodeIcon(baseCustomNodeIcon, networkSettings, adjustedSize, projectedNodes);
        var customEdgeIcon = determineEdgeIcon({
            baseCustomEdgeIcon: baseCustomEdgeIcon,
            networkSettings: networkSettings,
            size: adjustedSize,
            nodes: projectedNodes,
            graph: graph
        });
        if ((networkSettings.type === "sankey" ||
            networkSettings.type === "flowchart") &&
            networkDrawing_1.topologicalSort(projectedNodes, projectedEdges) === null) {
            networkSettings.customSankey = d3_sankey_circular_1.sankeyCircular;
        }
        networkSettings.width = size[0];
        networkSettings.height = size[1];
        var networkSettingsChanged = false;
        networkSettingsKeys.forEach(function (key) {
            if (key !== "edgeType" &&
                key !== "graphSettings" &&
                networkSettings[key] !== _this.state.graphSettings[key]) {
                networkSettingsChanged = true;
            }
        });
        //Support bubble chart with circle pack and with force
        if (networkSettings.type === "sankey") {
            edgeType = function (d) {
                return d.circular
                    ? networkDrawing_1.circularAreaLink(d)
                    : edgeType === "angled"
                        ? networkDrawing_1.ribbonLink(d)
                        : networkDrawing_1.areaLink(d);
            };
        }
        else if (isHierarchical) {
            projectedNodes.forEach(function (node) {
                if (createPointLayer) {
                    node.x = (node.x0 + node.x1) / 2;
                    node.y = (node.y0 + node.y1) / 2;
                }
                if (typeof networkSettings.type === "string" &&
                    hierarchicalProjectable[networkSettings.type] &&
                    networkSettings.projection === "horizontal") {
                    var ox = node.x;
                    node.x = node.y;
                    node.y = ox;
                    if (createPointLayer) {
                        var ox0 = node.x0;
                        var ox1 = node.x1;
                        node.x0 = node.y0;
                        node.x1 = node.y1;
                        node.y0 = ox0;
                        node.y1 = ox1;
                    }
                }
                else if (typeof networkSettings.type === "string" &&
                    radialProjectable[networkSettings.type] &&
                    networkSettings.projection === "radial") {
                    var radialPoint = node.depth === 0
                        ? [adjustedSize[0] / 2, adjustedSize[1] / 2]
                        : pieceDrawing_1.pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], node.x / adjustedSize[0], node.y / 2);
                    node.x = radialPoint[0];
                    node.y = radialPoint[1];
                }
                else {
                    node.x = node.x;
                    node.y = node.y;
                    if (createPointLayer) {
                        node.x0 = node.x0;
                        node.x1 = node.x1;
                        node.y0 = node.y0;
                        node.y1 = node.y1;
                    }
                }
            });
        }
        if (networkSettings.type !== "static" &&
            (changedData || networkSettingsChanged)) {
            var components = [
                {
                    componentNodes: projectedNodes,
                    componentEdges: projectedEdges
                }
            ];
            if (networkSettings.type === "chord") {
                var radius = adjustedSize[1] / 2;
                var _f = networkSettings.groupWidth, groupWidth = _f === void 0 ? 20 : _f, _g = networkSettings.padAngle, padAngle = _g === void 0 ? 0.01 : _g, sortGroups = networkSettings.sortGroups;
                var arcGenerator_1 = d3_shape_1.arc()
                    .innerRadius(radius - groupWidth)
                    .outerRadius(radius);
                var ribbonGenerator_1 = d3_chord_1.ribbon().radius(radius - groupWidth);
                var matrixifiedNetwork = matrixify({
                    edgeHash: edgeHash,
                    nodes: projectedNodes,
                    edgeWidthAccessor: edgeWidthAccessor,
                    nodeIDAccessor: nodeIDAccessor
                });
                var chordLayout = d3_chord_1.chord().padAngle(padAngle);
                if (sortGroups) {
                    chordLayout.sortGroups(sortGroups);
                }
                var chords = chordLayout(matrixifiedNetwork);
                var groups = chords.groups;
                groups.forEach(function (group) {
                    var groupCentroid = arcGenerator_1.centroid(group);
                    var groupD = arcGenerator_1(group);
                    var groupNode = projectedNodes[group.index];
                    groupNode.d = groupD;
                    groupNode.index = group.index;
                    groupNode.x = groupCentroid[0] + adjustedSize[0] / 2;
                    groupNode.y = groupCentroid[1] + adjustedSize[1] / 2;
                });
                chords.forEach(function (generatedChord) {
                    var chordD = ribbonGenerator_1(generatedChord);
                    //this is incorrect should use edgeHash
                    var nodeSourceID = nodeIDAccessor(projectedNodes[generatedChord.source.index]);
                    var nodeTargetID = nodeIDAccessor(projectedNodes[generatedChord.target.index]);
                    var chordEdge = edgeHash.get(nodeSourceID + "|" + nodeTargetID);
                    chordEdge.d = chordD;
                    var chordBounds = svg_path_bounding_box_1.default(chordD);
                    chordEdge.x =
                        adjustedSize[0] / 2 + (chordBounds.x1 + chordBounds.x2) / 2;
                    chordEdge.y =
                        adjustedSize[1] / 2 + (chordBounds.y1 + chordBounds.y2) / 2;
                });
            }
            else if (networkSettings.type === "sankey" ||
                networkSettings.type === "flowchart") {
                var _h = networkSettings.orient, orient = _h === void 0 ? "center" : _h, _j = networkSettings.iterations, iterations = _j === void 0 ? 100 : _j, nodePadding = networkSettings.nodePadding, _k = networkSettings.nodePaddingRatio, nodePaddingRatio = _k === void 0 ? nodePadding ? undefined : 0.5 : _k, _l = networkSettings.nodeWidth, nodeWidth = _l === void 0 ? networkSettings.type === "flowchart" ? 2 : 24 : _l, customSankey = networkSettings.customSankey, _m = networkSettings.direction, direction_1 = _m === void 0 ? "right" : _m;
                var sankeyOrient = sankeyOrientHash[orient];
                var actualSankey = customSankey || d3_sankey_circular_1.sankeyCircular;
                var frameExtent = [[0, 0], adjustedSize];
                if (networkSettings.direction === "up" ||
                    networkSettings.direction === "down") {
                    frameExtent = [[0, 0], [adjustedSize[1], adjustedSize[0]]];
                }
                var frameSankey = actualSankey()
                    .extent(frameExtent)
                    .links(projectedEdges)
                    .nodes(projectedNodes)
                    .nodeAlign(sankeyOrient)
                    .nodeId(nodeIDAccessor)
                    .nodeWidth(nodeWidth)
                    .iterations(iterations);
                if (frameSankey.nodePaddingRatio && nodePaddingRatio) {
                    frameSankey.nodePaddingRatio(nodePaddingRatio);
                }
                else if (nodePadding) {
                    frameSankey.nodePadding(nodePadding);
                }
                frameSankey();
                projectedNodes.forEach(function (d) {
                    d.height = d.y1 - d.y0;
                    d.width = d.x1 - d.x0;
                    d.x = d.x0 + d.width / 2;
                    d.y = d.y0 + d.height / 2;
                    d.radius = d.height / 2;
                    d.direction = direction_1;
                });
                projectedEdges.forEach(function (d) {
                    d.sankeyWidth = d.width;
                    d.direction = direction_1;
                    d.width = undefined;
                });
            }
            else if (networkSettings.type === "wordcloud") {
                var _o = networkSettings.iterations, iterations = _o === void 0 ? 500 : _o, _p = networkSettings.fontSize, fontSize_1 = _p === void 0 ? 18 : _p, rotate_1 = networkSettings.rotate, _q = networkSettings.fontWeight, fontWeight_1 = _q === void 0 ? 300 : _q, _r = networkSettings.textAccessor, textAccessor_1 = _r === void 0 ? function (d) { return d.text; } : _r;
                var fontWeightMod = (fontWeight_1 / 300 - 1) / 5 + 1;
                var fontWidth_1 = (fontSize_1 / 1.5) * fontWeightMod;
                projectedNodes.forEach(function (d, i) {
                    var calcualatedNodeSize = nodeSizeAccessor(d);
                    d._NWFText = textAccessor_1(d) || "";
                    var textWidth = fontWidth_1 * d._NWFText.length * calcualatedNodeSize * 1.4;
                    var textHeight = fontSize_1 * calcualatedNodeSize;
                    d.textHeight = textHeight + 4;
                    d.textWidth = textWidth + 4;
                    d.rotate = rotate_1 ? rotate_1(d, i) : 0;
                    d.fontSize = fontSize_1 * calcualatedNodeSize;
                    d.fontWeight = fontWeight_1;
                    d.radius = d.r = textWidth / 2;
                });
                projectedNodes.sort(function (a, b) { return b.textWidth - a.textWidth; });
                //bubblepack for initial position
                d3_hierarchy_1.packSiblings(projectedNodes);
                //        if (rotate) {
                var collide = d3_bboxCollide_1.bboxCollide(function (d) {
                    if (d.rotate) {
                        return [
                            [-d.textHeight / 2, -d.textWidth / 2],
                            [d.textHeight / 2, d.textWidth / 2]
                        ];
                    }
                    return [
                        [-d.textWidth / 2, -d.textHeight / 2],
                        [d.textWidth / 2, d.textHeight / 2]
                    ];
                }).iterations(1);
                var xCenter = size[0] / 2;
                var yCenter = size[1] / 2;
                var simulation = d3_force_1.forceSimulation(projectedNodes)
                    .velocityDecay(0.6)
                    .force("x", d3_force_1.forceX(xCenter).strength(1.2))
                    .force("y", d3_force_1.forceY(yCenter).strength(1.2))
                    .force("collide", collide);
                simulation.stop();
                for (var i = 0; i < iterations; ++i)
                    simulation.tick();
                //      }
                var xMin = d3_array_1.min(projectedNodes.map(function (p) { return p.x - (p.rotate ? p.textHeight / 2 : p.textWidth / 2); }));
                var xMax = d3_array_1.max(projectedNodes.map(function (p) { return p.x + (p.rotate ? p.textHeight / 2 : p.textWidth / 2); }));
                var yMin = d3_array_1.min(projectedNodes.map(function (p) { return p.y - (p.rotate ? p.textWidth / 2 : p.textHeight / 2); }));
                var yMax = d3_array_1.max(projectedNodes.map(function (p) { return p.y + (p.rotate ? p.textWidth / 2 : p.textHeight / 2); }));
                var projectionScaleX_1 = d3_scale_1.scaleLinear()
                    .domain([xMin, xMax])
                    .range([0, adjustedSize[0]]);
                var projectionScaleY_1 = d3_scale_1.scaleLinear()
                    .domain([yMin, yMax])
                    .range([0, adjustedSize[1]]);
                var xMod_1 = adjustedSize[0] / xMax;
                var yMod_1 = adjustedSize[1] / yMax;
                var sizeMod_1 = Math.min(xMod_1, yMod_1) * 1.2;
                projectedNodes.forEach(function (node) {
                    node.x = projectionScaleX_1(node.x);
                    node.y = projectionScaleY_1(node.y);
                    node.fontSize = node.fontSize * sizeMod_1;
                    node.scale = 1;
                    node.radius = node.r = Math.max((node.textHeight / 4) * yMod_1, (node.textWidth / 4) * xMod_1);
                    //      node.textHeight = projectionScaleY(node.textHeight)
                    //      node.textWidth = projectionScaleY(node.textWidth)
                });
            }
            else if (networkSettings.type === "force") {
                var _s = networkSettings.iterations, iterations = _s === void 0 ? 500 : _s, _t = networkSettings.edgeStrength, edgeStrength_1 = _t === void 0 ? 0.1 : _t, _u = networkSettings.distanceMax, distanceMax = _u === void 0 ? Infinity : _u, edgeDistance = networkSettings.edgeDistance;
                var linkForce = d3_force_1.forceLink().strength(function (d) {
                    return Math.min(2.5, d.weight ? d.weight * edgeStrength_1 : edgeStrength_1);
                });
                if (edgeDistance) {
                    linkForce.distance(edgeDistance);
                }
                var simulation = networkSettings.simulation ||
                    d3_force_1.forceSimulation().force("charge", d3_force_1.forceManyBody()
                        .distanceMax(distanceMax)
                        .strength(networkSettings.forceManyBody ||
                        (function (d) { return -25 * nodeSizeAccessor(d); })));
                //        simulation.force("link", linkForce).nodes(projectedNodes)
                simulation.nodes(projectedNodes);
                var forceMod = adjustedSize[1] / adjustedSize[0];
                if (!simulation.force("x")) {
                    simulation.force("x", d3_force_1.forceX(adjustedSize[0] / 2).strength(forceMod * 0.1));
                }
                if (!simulation.force("y")) {
                    simulation.force("y", d3_force_1.forceY(adjustedSize[1] / 2).strength(0.1));
                }
                if (projectedEdges.length !== 0 && !simulation.force("link")) {
                    simulation.force("link", linkForce);
                    simulation.force("link").links(projectedEdges);
                }
                //reset alpha if it's too cold
                if (simulation.alpha() < 0.1) {
                    simulation.alpha(1);
                }
                simulation.stop();
                for (var i = 0; i < iterations; ++i)
                    simulation.tick();
            }
            else if (networkSettings.type === "motifs") {
                var componentHash_1 = new Map();
                projectedEdges.forEach(function (edge) {
                    ;
                    [edge.source, edge.target].forEach(function (node) {
                        if (!componentHash_1.get(node)) {
                            componentHash_1.set(node, {
                                node: node,
                                component: -99,
                                connectedNodes: [],
                                edges: []
                            });
                        }
                    });
                    componentHash_1.get(edge.source).connectedNodes.push(edge.target);
                    componentHash_1.get(edge.target).connectedNodes.push(edge.source);
                    componentHash_1.get(edge.source).edges.push(edge);
                });
                components = breadthFirstCompontents(projectedNodes, componentHash_1);
                var largestComponent_1 = Math.max(projectedNodes.length / 3, components[0].componentNodes.length);
                var layoutSize_1 = size[0] > size[1] ? size[1] : size[0];
                var layoutDirection_1 = size[0] > size[1] ? "horizontal" : "vertical";
                var _v = networkSettings.iterations, iterations_1 = _v === void 0 ? 500 : _v, _w = networkSettings.edgeStrength, edgeStrength_2 = _w === void 0 ? 0.1 : _w, edgeDistance_1 = networkSettings.edgeDistance;
                var currentX_1 = 0;
                var currentY_1 = 0;
                components.forEach(function (_a) {
                    var componentNodes = _a.componentNodes, componentEdges = _a.componentEdges;
                    var linkForce = d3_force_1.forceLink().strength(function (d) {
                        return Math.min(2.5, d.weight ? d.weight * edgeStrength_2 : edgeStrength_2);
                    });
                    if (edgeDistance_1) {
                        linkForce.distance(edgeDistance_1);
                    }
                    var componentLayoutSize = Math.max(componentNodes.length / largestComponent_1, 0.2) * layoutSize_1;
                    var xBound = componentLayoutSize + currentX_1;
                    var yBound = componentLayoutSize + currentY_1;
                    if (layoutDirection_1 === "horizontal") {
                        if (yBound > size[1]) {
                            currentX_1 = componentLayoutSize + currentX_1;
                            currentY_1 = componentLayoutSize;
                        }
                        else {
                            currentY_1 = componentLayoutSize + currentY_1;
                        }
                    }
                    else {
                        if (xBound > size[0]) {
                            currentY_1 = componentLayoutSize + currentY_1;
                            currentX_1 = componentLayoutSize;
                        }
                        else {
                            currentX_1 = componentLayoutSize + currentX_1;
                        }
                    }
                    var xCenter = currentX_1 - componentLayoutSize / 2;
                    var yCenter = currentY_1 - componentLayoutSize / 2;
                    var simulation = d3_force_1.forceSimulation()
                        .force("charge", d3_force_1.forceManyBody().strength(networkSettings.forceManyBody ||
                        (function (d) { return -25 * nodeSizeAccessor(d); })))
                        .force("link", linkForce);
                    simulation
                        .force("x", d3_force_1.forceX(xCenter))
                        .force("y", d3_force_1.forceY(yCenter))
                        .nodes(componentNodes);
                    simulation.force("link").links(componentEdges);
                    simulation.stop();
                    for (var i = 0; i < iterations_1; ++i)
                        simulation.tick();
                    var maxX = d3_array_1.max(componentNodes.map(function (d) { return d.x; }));
                    var maxY = d3_array_1.max(componentNodes.map(function (d) { return d.y; }));
                    var minX = d3_array_1.min(componentNodes.map(function (d) { return d.x; }));
                    var minY = d3_array_1.min(componentNodes.map(function (d) { return d.y; }));
                    var resetX = d3_scale_1.scaleLinear()
                        .domain([minX, maxX])
                        .range([currentX_1 - componentLayoutSize, currentX_1 - 20]);
                    var resetY = d3_scale_1.scaleLinear()
                        .domain([minY, maxY])
                        .range([currentY_1 - componentLayoutSize, currentY_1 - 20]);
                    componentNodes.forEach(function (node) {
                        node.x = resetX(node.x);
                        node.y = resetY(node.y);
                    });
                });
            }
            else if (networkSettings.type === "matrix") {
                if (networkSettings.sort) {
                    projectedNodes = projectedNodes.sort(networkSettings.sort);
                }
                var gridSize = Math.min.apply(Math, __spread(adjustedSize));
                var stepSize_1 = gridSize / (projectedNodes.length + 1);
                projectedNodes.forEach(function (node, index) {
                    node.x = 0;
                    node.y = (index + 1) * stepSize_1;
                });
            }
            else if (networkSettings.type === "arc") {
                if (networkSettings.sort) {
                    projectedNodes = projectedNodes.sort(networkSettings.sort);
                }
                var stepSize_2 = adjustedSize[0] / (projectedNodes.length + 2);
                projectedNodes.forEach(function (node, index) {
                    node.x = (index + 1) * stepSize_2;
                    node.y = adjustedSize[1] / 2;
                });
            }
            else if (typeof networkSettings.type === "function") {
                networkSettings.type({
                    nodes: projectedNodes,
                    edges: projectedEdges
                });
            }
            else {
                projectedNodes.forEach(function (node) {
                    node.x = node.x === undefined ? (node.x0 + node.x1) / 2 : node.x;
                    node.y = node.y === undefined ? node.y0 : node.y;
                });
            }
            this.state.graphSettings.nodes = currentProps.nodes;
            this.state.graphSettings.edges = currentProps.edges;
        }
        //filter out user-defined nodes
        projectedNodes = projectedNodes.filter(filterRenderedNodes);
        projectedEdges = projectedEdges.filter(function (d) {
            return projectedNodes.indexOf(d.target) !== -1 &&
                projectedNodes.indexOf(d.source) !== -1;
        });
        if (networkSettings.direction === "flip") {
            projectedNodes.forEach(function (node) {
                // const ox = node.x
                // const oy = node.y
                node.x = adjustedSize[0] - node.x;
                node.y = adjustedSize[1] - node.y;
            });
        }
        else if (networkSettings.direction === "up" ||
            networkSettings.direction === "down") {
            var mod_1 = networkSettings.direction === "up"
                ? function (value) { return adjustedSize[1] - value; }
                : function (value) { return value; };
            projectedNodes.forEach(function (node) {
                var ox = node.x;
                var ox0 = node.x0;
                var ox1 = node.x1;
                node.x = mod_1(node.y);
                node.x0 = mod_1(node.y0);
                node.x1 = mod_1(node.y1);
                node.y = ox;
                node.y0 = ox0;
                node.y1 = ox1;
            });
        }
        else if (networkSettings.direction === "left") {
            projectedNodes.forEach(function (node) {
                node.x = adjustedSize[0] - node.x;
                node.x0 = adjustedSize[0] - node.x0;
                node.x1 = adjustedSize[0] - node.x1;
            });
        }
        if (typeof networkSettings.zoom === "function") {
            networkSettings.zoom(projectedNodes, adjustedSize);
        }
        else if (networkSettings.zoom !== false &&
            networkSettings.type !== "matrix" &&
            networkSettings.type !== "wordcloud" &&
            networkSettings.type !== "chord" &&
            networkSettings.type !== "sankey" &&
            networkSettings.type !== "partition" &&
            networkSettings.type !== "treemap" &&
            networkSettings.type !== "circlepack" &&
            networkSettings.type !== "dagre") {
            // ZOOM SHOULD MAINTAIN ASPECT RATIO, ADD "stretch" to fill whole area
            var xMin = d3_array_1.min(projectedNodes.map(function (p) { return p.x - nodeSizeAccessor(p); }));
            var xMax = d3_array_1.max(projectedNodes.map(function (p) { return p.x + nodeSizeAccessor(p); }));
            var yMin = d3_array_1.min(projectedNodes.map(function (p) { return p.y - nodeSizeAccessor(p); }));
            var yMax = d3_array_1.max(projectedNodes.map(function (p) { return p.y + nodeSizeAccessor(p); }));
            var xSize = Math.abs(xMax - xMin);
            var ySize = Math.abs(yMax - yMin);
            var networkAspectRatio = xSize / ySize;
            var baseAspectRatio = adjustedSize[0] / adjustedSize[1];
            var yMod = void 0, xMod = void 0;
            if (networkSettings.zoom === "stretch") {
                yMod = 0;
                xMod = 0;
            }
            else if (xSize > ySize) {
                if (networkAspectRatio > baseAspectRatio) {
                    xMod = 0;
                    yMod = (adjustedSize[1] - (adjustedSize[0] / xSize) * ySize) / 2;
                }
                else {
                    yMod = 0;
                    xMod = (adjustedSize[0] - (adjustedSize[1] / ySize) * xSize) / 2;
                }
            }
            else {
                if (networkAspectRatio > baseAspectRatio) {
                    xMod = 0;
                    yMod = (adjustedSize[1] - (adjustedSize[0] / xSize) * ySize) / 2;
                }
                else {
                    yMod = 0;
                    xMod = (adjustedSize[0] - (adjustedSize[1] / ySize) * xSize) / 2;
                }
            }
            var projectionScaleX_2 = d3_scale_1.scaleLinear()
                .domain([xMin, xMax])
                .range([xMod, adjustedSize[0] - xMod]);
            var projectionScaleY_2 = d3_scale_1.scaleLinear()
                .domain([yMin, yMax])
                .range([yMod, adjustedSize[1] - yMod]);
            projectedNodes.forEach(function (node) {
                node.x = projectionScaleX_2(node.x);
                node.y = projectionScaleY_2(node.y);
            });
        }
        else if (networkSettings.zoom !== false &&
            networkSettings.projection !== "radial" &&
            (networkSettings.type === "partition" ||
                networkSettings.type === "treemap" ||
                networkSettings.type === "dagre")) {
            var xMin = d3_array_1.min(projectedNodes.map(function (p) { return p.x0; }));
            var xMax = d3_array_1.max(projectedNodes.map(function (p) { return p.x1; }));
            var yMin = d3_array_1.min(projectedNodes.map(function (p) { return p.y0; }));
            var yMax = d3_array_1.max(projectedNodes.map(function (p) { return p.y1; }));
            var projectionScaleX_3 = d3_scale_1.scaleLinear()
                .domain([xMin, xMax])
                .range([margin.left, adjustedSize[0] - margin.right]);
            var projectionScaleY_3 = d3_scale_1.scaleLinear()
                .domain([yMin, yMax])
                .range([margin.top, adjustedSize[1] - margin.bottom]);
            projectedNodes.forEach(function (node) {
                node.x = projectionScaleX_3(node.x);
                node.y = projectionScaleY_3(node.y);
                node.x0 = projectionScaleX_3(node.x0);
                node.y0 = projectionScaleY_3(node.y0);
                node.x1 = projectionScaleX_3(node.x1);
                node.y1 = projectionScaleY_3(node.y1);
                node.zoomedHeight = node.y1 - node.y0;
                node.zoomedWidth = node.x1 - node.x0;
            });
            projectedEdges.forEach(function (edge) {
                if (edge.points) {
                    edge.points.forEach(function (p) {
                        p.x = projectionScaleX_3(p.x);
                        p.y = projectionScaleY_3(p.y);
                    });
                }
            });
        }
        projectedNodes.forEach(function (node) {
            node.nodeSize = nodeSizeAccessor(node);
        });
        projectedEdges.forEach(function (edge) {
            edge.width = edgeWidthAccessor(edge);
        });
        var legendSettings;
        if (currentProps.legend) {
            legendSettings = currentProps.legend;
            if (!legendSettings.legendGroups) {
                ///Something auto for networks
                var legendGroups = [
                    {
                        styleFn: currentProps.nodeStyle,
                        type: "fill",
                        items: []
                    }
                ];
                legendSettings.legendGroups = legendGroups;
            }
        }
        var networkFrameRender = {
            edges: {
                accessibleTransform: function (data, i) {
                    var edgeX = (data[i].source.x + data[i].target.x) / 2;
                    var edgeY = (data[i].source.y + data[i].target.y) / 2;
                    return __assign({ type: "frame-hover" }, data[i], { x: edgeX, y: edgeY });
                },
                data: projectedEdges,
                styleFn: dataFunctions_1.stringToFn(edgeStyle, function () { return ({}); }, true),
                classFn: dataFunctions_1.stringToFn(edgeClass, function () { return ""; }, true),
                renderMode: dataFunctions_1.stringToFn(edgeRenderMode, undefined, true),
                canvasRenderFn: canvasEdges && dataFunctions_1.stringToFn(canvasEdges, undefined, true),
                renderKeyFn: currentProps.edgeRenderKey
                    ? currentProps.edgeRenderKey
                    : function (d) { return d._NWFEdgeKey || d.source.id + "-" + d.target.id; },
                behavior: networkDrawing_1.drawEdges,
                projection: networkSettings.projection,
                type: edgeType,
                customMark: customEdgeIcon,
                networkType: networkSettings.type,
                direction: networkSettings.direction
            },
            nodes: {
                accessibleTransform: function (data, i) { return (__assign({ type: "frame-hover" }, data[i], (data[i].data || {}))); },
                data: projectedNodes,
                styleFn: nodeStyleFn,
                classFn: nodeClassFn,
                renderMode: nodeRenderModeFn,
                canvasRenderFn: nodeCanvasRenderFn,
                customMark: customNodeIcon,
                behavior: networkDrawing_1.drawNodes,
                renderKeyFn: currentProps.nodeRenderKey
            }
        };
        var nodeLabelAnnotations = [];
        if (currentProps.nodeLabels && projectedNodes) {
            projectedNodes.forEach(function (node, nodei) {
                var feasibleLabel = nodeLabels && nodeLabels !== true && nodeLabels(node);
                if (nodeLabels === true || feasibleLabel) {
                    var actualLabel = networkSettings.projection === "radial" && node.depth !== 0
                        ? networkDrawing_1.radialLabelGenerator(node, nodei, nodeLabels === true ? nodeIDAccessor : nodeLabels, adjustedSize)
                        : nodeLabels === true
                            ? nodeIDAccessor(node, nodei)
                            : feasibleLabel;
                    var nodeLabel = void 0;
                    if (React.isValidElement(actualLabel)) {
                        nodeLabel = {
                            key: "node-label-" + nodei,
                            type: "basic-node-label",
                            x: node.x,
                            y: node.y,
                            element: actualLabel
                        };
                    }
                    else {
                        nodeLabel = {
                            key: "node-label-" + nodei,
                            className: "node-label",
                            dx: 0,
                            dy: 0,
                            x: node.x,
                            y: node.y,
                            note: { label: actualLabel },
                            connector: { end: "none" },
                            type: AnnotationLabel_1.default,
                            subject: { radius: nodeSizeAccessor(node) + 2 }
                        };
                    }
                    nodeLabelAnnotations.push(nodeLabel);
                }
            });
        }
        var projectedXYPoints;
        var overlay = [];
        var areaBasedTypes = ["circlepack", "treemap", "partition", "chord"];
        if ((hoverAnnotation &&
            areaBasedTypes.find(function (d) { return d === networkSettings.type; })) ||
            hoverAnnotation === "area") {
            if (hoverAnnotation !== "edge") {
                var renderedNodeOverlays = projectedNodes.map(function (d, i) { return (__assign({ overlayData: d }, customNodeIcon({
                    d: d,
                    i: i,
                    transform: "translate(" + d.x + "," + d.y + ")",
                    styleFn: function () { return ({ fill: "pink", opacity: 0 }); }
                }).props)); });
                overlay.push.apply(overlay, __spread(renderedNodeOverlays));
            }
            if (hoverAnnotation !== "node") {
                projectedEdges.forEach(function (d, i) {
                    var generatedIcon = customEdgeIcon({
                        d: d,
                        i: i,
                        transform: "translate(" + d.x + "," + d.y + ")",
                        styleFn: function () { return ({ fill: "pink", opacity: 0 }); }
                    });
                    if (generatedIcon) {
                        overlay.push(__assign({ overlayData: __assign({}, d, { x: d.x || (d.source.x + d.target.x) / 2, y: d.y || (d.source.y + d.target.y) / 2, edge: true }) }, generatedIcon.props));
                    }
                });
            }
        }
        else if (hoverAnnotation === "edge" &&
            typeof networkSettings.type === "string" &&
            edgePointHash[networkSettings.type]) {
            projectedXYPoints = projectedEdges.map(edgePointHash[networkSettings.type]);
        }
        else if (Array.isArray(hoverAnnotation) ||
            hoverAnnotation === true ||
            hoverAnnotation === "node") {
            projectedXYPoints = projectedNodes;
            if (changedData || networkSettingsChanged)
                projectedXYPoints = __spread(projectedNodes);
        }
        else if (hoverAnnotation === "all" &&
            typeof networkSettings.type === "string") {
            projectedXYPoints = __spread(projectedEdges.map(edgePointHash[networkSettings.type]), projectedNodes);
        }
        this.setState({
            adjustedPosition: adjustedPosition,
            adjustedSize: adjustedSize,
            backgroundGraphics: currentProps.backgroundGraphics,
            foregroundGraphics: currentProps.foregroundGraphics,
            title: title,
            renderNumber: this.state.renderNumber + 1,
            projectedNodes: projectedNodes,
            projectedEdges: projectedEdges,
            projectedXYPoints: projectedXYPoints,
            overlay: overlay,
            nodeIDAccessor: nodeIDAccessor,
            sourceAccessor: sourceAccessor,
            targetAccessor: targetAccessor,
            nodeSizeAccessor: nodeSizeAccessor,
            edgeWidthAccessor: edgeWidthAccessor,
            margin: margin,
            legendSettings: legendSettings,
            networkFrameRender: networkFrameRender,
            nodeLabelAnnotations: nodeLabelAnnotations,
            graphSettings: __assign({}, networkSettings.graphSettings, networkSettings)
        });
    };
    NetworkFrame.prototype.render = function () {
        var _a = this.props, annotations = _a.annotations, annotationSettings = _a.annotationSettings, className = _a.className, customClickBehavior = _a.customClickBehavior, customDoubleClickBehavior = _a.customDoubleClickBehavior, customHoverBehavior = _a.customHoverBehavior, size = _a.size, matte = _a.matte, hoverAnnotation = _a.hoverAnnotation, beforeElements = _a.beforeElements, afterElements = _a.afterElements, interaction = _a.interaction, disableContext = _a.disableContext, canvasPostProcess = _a.canvasPostProcess, baseMarkProps = _a.baseMarkProps, useSpans = _a.useSpans, canvasNodes = _a.canvasNodes, canvasEdges = _a.canvasEdges, name = _a.name, downloadFields = _a.downloadFields, download = _a.download, additionalDefs = _a.additionalDefs, _b = _a.renderOrder, renderOrder = _b === void 0 ? this.state.graphSettings &&
            this.state.graphSettings.type === "matrix"
            ? matrixRenderOrder
            : generalRenderOrder : _b;
        var _c = this.state, backgroundGraphics = _c.backgroundGraphics, foregroundGraphics = _c.foregroundGraphics, projectedXYPoints = _c.projectedXYPoints, margin = _c.margin, legendSettings = _c.legendSettings, adjustedPosition = _c.adjustedPosition, adjustedSize = _c.adjustedSize, networkFrameRender = _c.networkFrameRender, nodeLabelAnnotations = _c.nodeLabelAnnotations, overlay = _c.overlay, projectedNodes = _c.projectedNodes, projectedEdges = _c.projectedEdges, title = _c.title;
        var downloadButton = [];
        if (download && projectedNodes.length > 0) {
            downloadButton.push(React.createElement(DownloadButton_1.default, { key: "network-download-nodes", csvName: name + "-" + new Date().toJSON(), width: size[0], label: "Download Node List", data: downloadDataMapping_1.networkNodeDownloadMapping({
                    data: projectedNodes,
                    fields: downloadFields
                }) }));
        }
        if (download && projectedEdges.length > 0) {
            downloadButton.push(React.createElement(DownloadButton_1.default, { key: "network-download-edges", csvName: name + "-" + new Date().toJSON(), width: size[0], label: "Download Edge List", data: downloadDataMapping_1.networkEdgeDownloadMapping({
                    data: projectedEdges,
                    fields: downloadFields
                }) }));
        }
        var formattedOverlay;
        if (overlay && overlay.length > 0) {
            formattedOverlay = overlay;
        }
        return (React.createElement(Frame_1.default, { name: "networkframe", renderPipeline: networkFrameRender, adjustedPosition: adjustedPosition, adjustedSize: adjustedSize, size: size, xScale: xScale, yScale: yScale, title: title, matte: matte, className: className, additionalDefs: additionalDefs, frameKey: "none", projectedCoordinateNames: projectedCoordinateNames, defaultSVGRule: this.defaultNetworkSVGRule, defaultHTMLRule: this.defaultNetworkHTMLRule, hoverAnnotation: Array.isArray(hoverAnnotation) ? hoverAnnotation : !!hoverAnnotation, annotations: __spread(annotations, nodeLabelAnnotations), annotationSettings: annotationSettings, legendSettings: legendSettings, interaction: interaction, customClickBehavior: customClickBehavior, customHoverBehavior: customHoverBehavior, customDoubleClickBehavior: customDoubleClickBehavior, points: projectedXYPoints, margin: margin, overlay: formattedOverlay, backgroundGraphics: backgroundGraphics, foregroundGraphics: foregroundGraphics, beforeElements: beforeElements, afterElements: afterElements, downloadButton: downloadButton, disableContext: disableContext, canvasPostProcess: canvasPostProcess, baseMarkProps: baseMarkProps, useSpans: !!useSpans, canvasRendering: !!(canvasNodes || canvasEdges), renderOrder: renderOrder, disableCanvasInteraction: true }));
    };
    NetworkFrame.defaultProps = {
        annotations: [],
        foregroundGraphics: [],
        annotationSettings: {},
        size: [500, 500],
        className: "",
        name: "networkframe",
        networkType: { type: "force", iterations: 500 },
        filterRenderedNodes: function (d) { return d.id !== "root-generated"; }
    };
    NetworkFrame.displayName = "NetworkFrame";
    return NetworkFrame;
}(React.Component));
exports.default = NetworkFrame;
//# sourceMappingURL=NetworkFrame.js.map