"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var d3_brush_1 = require("d3-brush");
var d3_array_1 = require("d3-array");
var d3_selection_1 = require("d3-selection");
var d3_voronoi_1 = require("d3-voronoi");
var semiotic_mark_1 = require("semiotic-mark");
// components
var Brush_1 = require("./Brush");
var SpanOrDiv_1 = require("./SpanOrDiv");
var coordinateNames_1 = require("./constants/coordinateNames");
var generateOMappingFn = function (projectedColumns) { return function (d) {
    if (d) {
        var columnValues = Object.values(projectedColumns);
        var foundColumns = columnValues.filter(function (c) {
            return d[1] >= c.x && d[0] <= c.x + c.width;
        });
        return foundColumns;
    }
    return null;
}; };
var generateOEndMappingFn = function (projectedColumns) { return function (d) {
    if (d &&
        d3_selection_1.event.sourceEvent &&
        d3_selection_1.event.sourceEvent.path &&
        d3_selection_1.event.sourceEvent.path[1] &&
        d3_selection_1.event.sourceEvent.path[1].classList.contains("xybrush") &&
        d3_selection_1.event.target.move) {
        var columnValues = Object.values(projectedColumns);
        var foundColumns = columnValues.filter(function (c) { return d[1] >= c.x && d[0] <= c.x + c.width; });
        var firstColumn = foundColumns[0] || {
            x: 0,
            width: 0
        };
        var lastColumn = foundColumns[foundColumns.length - 1] || {
            x: 0,
            width: 0
        };
        var columnPosition = [
            firstColumn.x + Math.min(5, firstColumn.width / 10),
            lastColumn.x + lastColumn.width - Math.min(5, lastColumn.width / 10)
        ];
        d3_selection_1.select(d3_selection_1.event.sourceEvent.path[1])
            .transition(750)
            .call(d3_selection_1.event.target.move, columnPosition);
        return foundColumns;
    }
    return null;
}; };
var InteractionLayer = /** @class */ (function (_super) {
    __extends(InteractionLayer, _super);
    function InteractionLayer(props) {
        var _this = _super.call(this, props) || this;
        _this.interactionContext = null;
        _this.canvasMap = new Map();
        _this.constructDataObject = function (d) {
            if (d === undefined)
                return d;
            var points = _this.props.points;
            return d && d.data ? __assign({ points: points }, d.data, d) : __assign({ points: points }, d);
        };
        _this.changeVoronoi = function (d, customHoverTypes) {
            var _a = _this.props, customHoverBehavior = _a.customHoverBehavior, voronoiHover = _a.voronoiHover;
            //Until semiotic 2
            var dataObject = _this.constructDataObject(d);
            if (customHoverBehavior)
                customHoverBehavior(dataObject);
            if (!d)
                voronoiHover(null);
            else if (customHoverTypes === true) {
                var vorD = Object.assign({}, dataObject);
                vorD.type = vorD.type === "column-hover" ? "column-hover" : "frame-hover";
                voronoiHover(vorD);
            }
            else if (customHoverTypes) {
                var arrayWrappedHoverTypes = Array.isArray(customHoverTypes)
                    ? customHoverTypes
                    : [customHoverTypes];
                var mappedHoverTypes = arrayWrappedHoverTypes
                    .map(function (c) {
                    var finalC = typeof c === "function" ? c(dataObject) : c;
                    if (!finalC)
                        return undefined;
                    return Object.assign({}, dataObject, finalC);
                })
                    .filter(function (d) { return d; });
                voronoiHover(mappedHoverTypes);
            }
        };
        _this.clickVoronoi = function (d) {
            //Until semiotic 2
            var dataObject = _this.constructDataObject(d);
            if (_this.props.customClickBehavior)
                _this.props.customClickBehavior(dataObject);
        };
        _this.doubleclickVoronoi = function (d) {
            //Until semiotic 2
            var dataObject = _this.constructDataObject(d);
            if (_this.props.customDoubleClickBehavior)
                _this.props.customDoubleClickBehavior(dataObject);
        };
        _this.brushStart = function (e, column, data) {
            if (_this.props.interaction && _this.props.interaction.start)
                _this.props.interaction.start(e, column, data);
        };
        _this.brush = function (e, column, data) {
            if (_this.props.interaction && _this.props.interaction.during)
                _this.props.interaction.during(e, column, data);
        };
        _this.brushEnd = function (e, column, data) {
            if (_this.props.interaction && _this.props.interaction.end)
                _this.props.interaction.end(e, column, data);
        };
        _this.createBrush = function (interaction) {
            var semioticBrush, mappingFn, selectedExtent, endMappingFn;
            var _a = _this.props, xScale = _a.xScale, yScale = _a.yScale, size = _a.size, renderPipeline = _a.renderPipeline;
            var brushData = {};
            Object.entries(renderPipeline).forEach(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                if (value.data && value.data.length > 0) {
                    brushData[key] = value.data;
                }
            });
            var projection = interaction.projection, projectedColumns = interaction.projectedColumns;
            var actualBrush = interaction.brush === "oBrush"
                ? projection === "horizontal"
                    ? "yBrush"
                    : "xBrush"
                : interaction.brush;
            var _b = interaction.extent, extent = _b === void 0 ? actualBrush === "xyBrush"
                ? [
                    [xScale.invert(0), yScale.invert(0)],
                    [xScale.invert(size[0]), yScale.invert(size[1])]
                ]
                : actualBrush === "xBrush"
                    ? [xScale.invert(0), xScale.invert(size[0])]
                    : [yScale.invert(0), yScale.invert(size[1])] : _b;
            if (extent.indexOf && extent.indexOf(undefined) !== -1) {
                return React.createElement("g", null);
            }
            if (actualBrush === "xBrush") {
                var castExtent = extent;
                mappingFn = function (d) {
                    return !d ? null : [xScale.invert(d[0]), xScale.invert(d[1])];
                };
                semioticBrush = d3_brush_1.brushX();
                selectedExtent = castExtent.map(function (d) { return xScale(d); });
                endMappingFn = mappingFn;
            }
            else if (actualBrush === "yBrush") {
                var castExtent = extent;
                mappingFn = function (d) {
                    return !d
                        ? null
                        : [yScale.invert(d[0]), yScale.invert(d[1])].sort(function (a, b) { return a - b; });
                };
                semioticBrush = d3_brush_1.brushY();
                selectedExtent = castExtent.map(function (d) { return yScale(d); }).sort(function (a, b) { return a - b; });
                endMappingFn = mappingFn;
            }
            else {
                var castExtent = extent;
                if (castExtent.indexOf(undefined) !== -1 ||
                    castExtent[0].indexOf(undefined) !== -1 ||
                    castExtent[1].indexOf(undefined) !== -1) {
                    return React.createElement("g", null);
                }
                semioticBrush = d3_brush_1.brush();
                mappingFn = function (d) {
                    if (!d)
                        return null;
                    var yValues = [yScale.invert(d[0][1]), yScale.invert(d[1][1])].sort(function (a, b) { return a - b; });
                    return [
                        [xScale.invert(d[0][0]), yValues[0]],
                        [xScale.invert(d[1][0]), yValues[1]]
                    ];
                };
                var yValues_1 = [yScale(extent[0][1]), yScale(extent[1][1])].sort(function (a, b) { return a - b; });
                selectedExtent = castExtent.map(function (d, i) { return [xScale(d[0]), yValues_1[i]]; });
                endMappingFn = mappingFn;
            }
            if (interaction.brush === "oBrush") {
                selectedExtent = null;
                if (interaction.extent) {
                    var _c = __read(interaction.extent, 2), leftExtent = _c[0], rightExtent = _c[1];
                    if ((typeof leftExtent === "string" || typeof leftExtent === "number") &&
                        (typeof rightExtent === "string" || typeof rightExtent === "number")) {
                        selectedExtent = [
                            projectedColumns[leftExtent].x,
                            projectedColumns[rightExtent].x +
                                projectedColumns[rightExtent].width
                        ];
                    }
                }
                mappingFn = generateOMappingFn(projectedColumns);
                endMappingFn = generateOEndMappingFn(projectedColumns);
            }
            semioticBrush
                .extent([[0, 0], [_this.props.size[0], _this.props.size[1]]])
                .on("start", function () {
                _this.brushStart(mappingFn(d3_selection_1.event.selection), undefined, brushData);
            })
                .on("brush", function () {
                _this.brush(mappingFn(d3_selection_1.event.selection), undefined, brushData);
            })
                .on("end", function () {
                _this.brushEnd(endMappingFn(d3_selection_1.event.selection), undefined, brushData);
            });
            return (React.createElement("g", { className: "brush" },
                React.createElement(Brush_1.default, { selectedExtent: selectedExtent, extent: extent, svgBrush: semioticBrush })));
        };
        _this.calculateOverlay = function (props) {
            var voronoiPaths = [];
            var xScale = props.xScale, yScale = props.yScale, points = props.points, projectedX = props.projectedX, showLinePoints = props.showLinePoints, size = props.size, overlay = props.overlay, _a = props.interactionOverflow, interactionOverflow = _a === void 0 ? { top: 0, bottom: 0, left: 0, right: 0 } : _a, customClickBehavior = props.customClickBehavior, customDoubleClickBehavior = props.customDoubleClickBehavior, hoverAnnotation = props.hoverAnnotation;
            var whichPoints = {
                top: coordinateNames_1.projectedYTop,
                bottom: coordinateNames_1.projectedYBottom
            };
            var pointerStyle = customClickBehavior || customDoubleClickBehavior
                ? { cursor: "pointer" }
                : {};
            if (points && hoverAnnotation && !overlay) {
                var voronoiDataset_1 = [];
                var voronoiUniqueHash_1 = {};
                points.forEach(function (d) {
                    var xValue = Math.floor(xScale(d[projectedX]));
                    var yValue = Math.floor(yScale(showLinePoints && d[whichPoints[showLinePoints]] !== undefined
                        ? d[whichPoints[showLinePoints]]
                        : d[coordinateNames_1.projectedYMiddle] !== undefined
                            ? d[coordinateNames_1.projectedYMiddle]
                            : d[coordinateNames_1.projectedY]));
                    if (xValue >= 0 &&
                        xValue <= size[0] &&
                        yValue >= 0 &&
                        yValue <= size[1] &&
                        xValue !== undefined &&
                        yValue !== undefined &&
                        isNaN(xValue) === false &&
                        isNaN(yValue) === false) {
                        var pointKey = xValue + "," + yValue;
                        if (!voronoiUniqueHash_1[pointKey]) {
                            var voronoiPoint = __assign({}, d, { coincidentPoints: [d], voronoiX: xValue, voronoiY: yValue });
                            voronoiDataset_1.push(voronoiPoint);
                            voronoiUniqueHash_1[pointKey] = voronoiPoint;
                        }
                        else
                            voronoiUniqueHash_1[pointKey].coincidentPoints.push(d);
                    }
                });
                var voronoiXExtent = d3_array_1.extent(voronoiDataset_1.map(function (d) { return d.voronoiX; }));
                var voronoiYExtent = d3_array_1.extent(voronoiDataset_1.map(function (d) { return d.voronoiY; }));
                var voronoiExtent = [
                    [
                        Math.min(voronoiXExtent[0], -interactionOverflow.left),
                        Math.min(voronoiYExtent[0], -interactionOverflow.top)
                    ],
                    [
                        Math.max(voronoiXExtent[1], size[0] + interactionOverflow.right),
                        Math.max(voronoiYExtent[1], size[1] + interactionOverflow.bottom)
                    ]
                ];
                var voronoiDiagram = d3_voronoi_1.voronoi()
                    .extent(voronoiExtent)
                    .x(function (d) { return d.voronoiX; })
                    .y(function (d) { return d.voronoiY; });
                var voronoiData = voronoiDiagram.polygons(voronoiDataset_1);
                voronoiPaths = voronoiData.map(function (d, i) {
                    return (React.createElement("path", { onClick: function () {
                            _this.clickVoronoi(voronoiDataset_1[i]);
                        }, onDoubleClick: function () {
                            _this.doubleclickVoronoi(voronoiDataset_1[i]);
                        }, onMouseEnter: function () {
                            _this.changeVoronoi(voronoiDataset_1[i], props.hoverAnnotation);
                        }, onMouseLeave: function () {
                            _this.changeVoronoi();
                        }, key: "interactionVoronoi" + i, d: "M" + d.join("L") + "Z", style: __assign({ fillOpacity: 0 }, pointerStyle) }));
                }, _this);
                return voronoiPaths;
            }
            else if (overlay) {
                var renderedOverlay = overlay.map(function (overlayRegion, i) {
                    var overlayData = overlayRegion.overlayData, rest = __rest(overlayRegion, ["overlayData"]);
                    if (React.isValidElement(overlayRegion.renderElement)) {
                        var overlayProps = {
                            key: "overlay-" + i,
                            onMouseEnter: function () {
                                _this.changeVoronoi(overlayData, props.hoverAnnotation);
                            },
                            onMouseLeave: function () {
                                _this.changeVoronoi();
                            },
                            onClick: function () {
                                _this.clickVoronoi(overlayData);
                            },
                            onDoubleClick: function () {
                                _this.doubleclickVoronoi(overlayData);
                            },
                            style: __assign({ opacity: 0 }, pointerStyle)
                        };
                        return React.cloneElement(overlayRegion.renderElement, overlayProps);
                    }
                    else {
                        return (React.createElement(semiotic_mark_1.Mark, __assign({ forceUpdate: true }, rest, { key: "overlay-" + i, onMouseEnter: function () {
                                _this.changeVoronoi(overlayData, props.hoverAnnotation);
                            }, onMouseLeave: function () {
                                _this.changeVoronoi();
                            }, onClick: function () {
                                _this.clickVoronoi(overlayData);
                            }, onDoubleClick: function () {
                                _this.doubleclickVoronoi(overlayData);
                            }, style: __assign({ opacity: 0 }, pointerStyle) })));
                    }
                });
                return renderedOverlay;
            }
        };
        _this.canvasRendering = function () {
            if (_this.interactionContext === null || !_this.state.overlayRegions)
                return;
            var _a = _this.props, svgSize = _a.svgSize, margin = _a.margin;
            var overlayRegions = _this.state.overlayRegions;
            _this.canvasMap.clear();
            var interactionContext = _this.interactionContext.getContext("2d");
            interactionContext.imageSmoothingEnabled = false;
            interactionContext.setTransform(1, 0, 0, 1, margin.left, margin.top);
            interactionContext.clearRect(-margin.left, -margin.top, svgSize[0], svgSize[1]);
            interactionContext.lineWidth = 1;
            overlayRegions.forEach(function (overlay, oi) {
                var interactionRGBA = "rgba(" + Math.floor(Math.random() * 255) + "," + Math.floor(Math.random() * 255) + "," + Math.floor(Math.random() * 255) + ",255)";
                _this.canvasMap.set(interactionRGBA, oi);
                interactionContext.fillStyle = interactionRGBA;
                interactionContext.strokeStyle = interactionRGBA;
                var p = new Path2D(overlay.props.d);
                interactionContext.stroke(p);
                interactionContext.fill(p);
            });
        };
        _this.createColumnsBrush = function (interaction) {
            var _a = _this.props, projection = _a.projection, rScale = _a.rScale, size = _a.size, oColumns = _a.oColumns, renderPipeline = _a.renderPipeline;
            if (!projection || !rScale || !oColumns)
                return;
            var brushData = {};
            Object.entries(renderPipeline).forEach(function (_a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                if (value.data && value.data.length > 0) {
                    brushData[key] = value.data;
                }
            });
            var semioticBrush, mappingFn;
            var max = rScale.domain()[1];
            if (projection && projection === "horizontal") {
                mappingFn = function (d) {
                    return !d ? null : [rScale.invert(d[0]), rScale.invert(d[1])];
                };
            }
            else
                mappingFn = function (d) {
                    return !d
                        ? null
                        : [
                            Math.abs(rScale.invert(d[1]) - max),
                            Math.abs(rScale.invert(d[0]) - max)
                        ];
                };
            var rRange = rScale.range();
            var columnHash = oColumns;
            var brushPosition, selectedExtent;
            var brushes = Object.keys(columnHash).map(function (c) {
                if (projection && projection === "horizontal") {
                    selectedExtent = interaction.extent[c]
                        ? interaction.extent[c].map(function (d) { return rScale(d); })
                        : rRange;
                    brushPosition = [0, columnHash[c].x];
                    semioticBrush = d3_brush_1.brushX();
                    semioticBrush
                        .extent([[rRange[0], 0], [rRange[1], columnHash[c].width]])
                        .on("start", function () {
                        _this.brushStart(mappingFn(d3_selection_1.event.selection), c, brushData);
                    })
                        .on("brush", function () {
                        _this.brush(mappingFn(d3_selection_1.event.selection), c, brushData);
                    })
                        .on("end", function () {
                        _this.brushEnd(mappingFn(d3_selection_1.event.selection), c, brushData);
                    });
                }
                else {
                    selectedExtent = interaction.extent[c]
                        ? interaction.extent[c].map(function (d) { return rRange[1] - rScale(d); }).reverse()
                        : rRange;
                    brushPosition = [columnHash[c].x, 0];
                    semioticBrush = d3_brush_1.brushY();
                    semioticBrush
                        .extent([[0, rRange[0]], [columnHash[c].width, rRange[1]]])
                        .on("start", function () {
                        _this.brushStart(mappingFn(d3_selection_1.event.selection), c, brushData);
                    })
                        .on("brush", function () {
                        _this.brush(mappingFn(d3_selection_1.event.selection), c, brushData);
                    })
                        .on("end", function () {
                        _this.brushEnd(mappingFn(d3_selection_1.event.selection), c, brushData);
                    });
                }
                return (React.createElement("g", { key: "column-brush-" + c, className: "brush" },
                    React.createElement(Brush_1.default, { key: "orbrush" + c, selectedExtent: selectedExtent, svgBrush: semioticBrush, position: brushPosition })));
            });
            return brushes;
        };
        _this.state = {
            overlayRegions: _this.calculateOverlay(props),
            interactionCanvas: (React.createElement("canvas", { className: "frame-canvas-interaction", ref: function (canvasContext) {
                    if (canvasContext) {
                        canvasContext.onmousemove = function (e) {
                            var interactionContext = canvasContext.getContext("2d");
                            var hoverPoint = interactionContext.getImageData(e.offsetX, e.offsetY, 1, 1);
                            var mostCommonRGB = "rgba(" + hoverPoint.data[0] + "," + hoverPoint.data[1] + "," + hoverPoint.data[2] + ",255)";
                            var overlay = _this.state.overlayRegions[_this.canvasMap.get(mostCommonRGB)];
                            if (!overlay) {
                                var hoverArea = interactionContext.getImageData(e.offsetX - 2, e.offsetY - 2, 5, 5);
                                var x = 0;
                                while (!overlay && x < 100) {
                                    overlay = _this.state.overlayRegions[_this.canvasMap.get("rgba(" + hoverArea.data[x] + "," + hoverArea.data[x + 1] + "," + hoverArea.data[x + 2] + ",255)")];
                                    x += 4;
                                }
                            }
                            if (overlay && overlay.props) {
                                overlay.props.onMouseEnter();
                            }
                            else {
                                _this.changeVoronoi();
                            }
                        };
                    }
                    _this.interactionContext = canvasContext;
                }, style: {
                    position: "absolute",
                    left: "0px",
                    top: "0px",
                    imageRendering: "pixelated",
                    pointerEvents: "all",
                    opacity: 0
                }, width: props.svgSize[0], height: props.svgSize[1] }))
        };
        return _this;
    }
    InteractionLayer.prototype.componentWillReceiveProps = function (nextProps) {
        if (this.props.overlay !== nextProps.overlay ||
            nextProps.points !== this.props.points ||
            this.props.xScale !== nextProps.xScale ||
            this.props.yScale !== nextProps.yScale ||
            this.props.hoverAnnotation !== nextProps.hoverAnnotation) {
            this.setState({ overlayRegions: this.calculateOverlay(nextProps) });
        }
    };
    InteractionLayer.prototype.componentDidMount = function () {
        this.canvasRendering();
    };
    InteractionLayer.prototype.componentDidUpdate = function (prevProps, prevState) {
        if (this.state.overlayRegions !== prevState.overlayRegions) {
            this.canvasRendering();
        }
    };
    InteractionLayer.prototype.render = function () {
        var semioticBrush = null;
        var _a = this.props, interaction = _a.interaction, svgSize = _a.svgSize, margin = _a.margin, _b = _a.useSpans, useSpans = _b === void 0 ? false : _b, canvasRendering = _a.canvasRendering, disableCanvasInteraction = _a.disableCanvasInteraction;
        var overlayRegions = this.state.overlayRegions;
        var enabled = this.props.enabled;
        if (interaction && interaction.brush) {
            enabled = true;
            semioticBrush = this.createBrush(interaction);
        }
        if (interaction && interaction.columnsBrush) {
            enabled = true;
            semioticBrush = this.createColumnsBrush(interaction);
        }
        if (!overlayRegions && !semioticBrush) {
            return null;
        }
        var interactionCanvas = !disableCanvasInteraction &&
            canvasRendering &&
            this.state.overlayRegions &&
            this.state.interactionCanvas;
        return (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "interaction-layer", style: {
                position: "absolute",
                background: "none",
                pointerEvents: "none"
            } }, interactionCanvas || (React.createElement("svg", { height: svgSize[1], width: svgSize[0], style: { background: "none", pointerEvents: "none" } },
            React.createElement("g", { className: "interaction-overlay", transform: "translate(" + margin.left + "," + margin.top + ")", style: { pointerEvents: enabled ? "all" : "none" } },
                React.createElement("g", { className: "interaction-regions" }, overlayRegions),
                semioticBrush)))));
    };
    InteractionLayer.defaultProps = {
        svgSize: [500, 500]
    };
    return InteractionLayer;
}(React.Component));
exports.default = InteractionLayer;
//# sourceMappingURL=InteractionLayer.js.map