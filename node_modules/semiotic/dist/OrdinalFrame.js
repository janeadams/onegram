"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var d3_collection_1 = require("d3-collection");
var d3_scale_1 = require("d3-scale");
var d3_array_1 = require("d3-array");
var d3_shape_1 = require("d3-shape");
var frame_props_1 = require("./constants/frame_props");
var orframeRules_1 = require("./annotationRules/orframeRules");
var baseRules_1 = require("./annotationRules/baseRules");
var multiAccessorUtils_1 = require("./data/multiAccessorUtils");
var Frame_1 = require("./Frame");
var DownloadButton_1 = require("./DownloadButton");
var downloadDataMapping_1 = require("./downloadDataMapping");
var frameFunctions_1 = require("./svg/frameFunctions");
var pieceDrawing_1 = require("./svg/pieceDrawing");
var pieceLayouts_1 = require("./svg/pieceLayouts");
var summaryLayouts_1 = require("./svg/summaryLayouts");
var dataFunctions_1 = require("./data/dataFunctions");
var functions_1 = require("./untyped_utilities/functions");
var xScale = d3_scale_1.scaleLinear();
var yScale = d3_scale_1.scaleLinear();
var midMod = function (d) { return (d.middle ? d.middle : 0); };
var zeroFunction = functions_1.genericFunction(0);
var twoPI = Math.PI * 2;
var naturalLanguageTypes = {
    bar: { items: "bar", chart: "bar chart" },
    clusterbar: { items: "bar", chart: "grouped bar chart" },
    swarm: { items: "point", chart: "swarm plot" },
    point: { items: "point", chart: "point plot" },
    timeline: { items: "bar", chart: "timeline" }
};
var projectedCoordinatesObject = { y: "y", x: "x" };
var defaultOverflow = { top: 0, bottom: 0, left: 0, right: 0 };
var layoutHash = {
    clusterbar: pieceLayouts_1.clusterBarLayout,
    bar: pieceLayouts_1.barLayout,
    point: pieceLayouts_1.pointLayout,
    swarm: pieceLayouts_1.swarmLayout,
    timeline: pieceLayouts_1.timelineLayout
};
var OrdinalFrame = /** @class */ (function (_super) {
    __extends(OrdinalFrame, _super);
    function OrdinalFrame(props) {
        var _this = _super.call(this, props) || this;
        _this.calculateOrdinalFrame = function (currentProps) {
            var oLabels;
            var projectedColumns = {};
            var _a = currentProps.oPadding, padding = _a === void 0 ? 0 : _a, baseSummaryType = currentProps.summaryType, baseType = currentProps.type, baseConnectorType = currentProps.connectorType, baseOAccessor = currentProps.oAccessor, baseRAccessor = currentProps.rAccessor, baseConnectorStyle = currentProps.connectorStyle, baseStyle = currentProps.style, baseRExtent = currentProps.rExtent, oSort = currentProps.oSort, _b = currentProps.sortO, sortO = _b === void 0 ? oSort : _b, basePieceClass = currentProps.pieceClass, baseSummaryStyle = currentProps.summaryStyle, baseSummaryClass = currentProps.summaryClass, dynamicColumnWidth = currentProps.dynamicColumnWidth, projection = currentProps.projection, customHoverBehavior = currentProps.customHoverBehavior, customClickBehavior = currentProps.customClickBehavior, customDoubleClickBehavior = currentProps.customDoubleClickBehavior, size = currentProps.size, pixelColumnWidth = currentProps.pixelColumnWidth, baseTitle = currentProps.title, oLabel = currentProps.oLabel, hoverAnnotation = currentProps.hoverAnnotation, pieceHoverAnnotation = currentProps.pieceHoverAnnotation, summaryHoverAnnotation = currentProps.summaryHoverAnnotation, backgroundGraphics = currentProps.backgroundGraphics, foregroundGraphics = currentProps.foregroundGraphics, oScaleType = currentProps.oScaleType, rScaleType = currentProps.rScaleType, legend = currentProps.legend, baseRenderKey = currentProps.renderKey, data = currentProps.data, baseMargin = currentProps.margin, baseOExtent = currentProps.oExtent, axes = currentProps.axes, _c = currentProps.axis, baseAxis = _c === void 0 ? axes : _c, basePieceIDAccessor = currentProps.pieceIDAccessor, baseSummaryPosition = currentProps.summaryPosition, multiAxis = currentProps.multiAxis, _d = currentProps.baseMarkProps, baseMarkProps = _d === void 0 ? {} : _d;
            var summaryType = frameFunctions_1.objectifyType(baseSummaryType);
            var pieceType = frameFunctions_1.objectifyType(baseType);
            var connectorType = frameFunctions_1.objectifyType(baseConnectorType);
            var oAccessor = dataFunctions_1.stringToArrayFn(baseOAccessor, function (d) { return d.renderKey; });
            var rAccessor = dataFunctions_1.stringToArrayFn(baseRAccessor, function (d) { return d.value || 1; });
            var renderKey = dataFunctions_1.stringToFn(baseRenderKey, function (d, i) { return i; });
            var eventListenersGenerator = function () { return ({}); };
            var connectorStyle = dataFunctions_1.stringToFn(baseConnectorStyle, function () { return ({}); }, true);
            var summaryStyle = dataFunctions_1.stringToFn(baseSummaryStyle, function () { return ({}); }, true);
            var pieceStyle = dataFunctions_1.stringToFn(baseStyle, function () { return ({}); }, true);
            var pieceClass = dataFunctions_1.stringToFn(basePieceClass, function () { return ""; }, true);
            var summaryClass = dataFunctions_1.stringToFn(baseSummaryClass, function () { return ""; }, true);
            var summaryPosition = baseSummaryPosition || (function (position) { return position; });
            var title = typeof baseTitle === "object" &&
                !React.isValidElement(baseTitle) &&
                baseTitle !== null
                ? baseTitle
                : { title: baseTitle, orient: "top" };
            var pieceIDAccessor = dataFunctions_1.stringToFn(basePieceIDAccessor, function () { return ""; });
            var _e = frameFunctions_1.keyAndObjectifyBarData({
                data: data,
                renderKey: renderKey,
                oAccessor: oAccessor,
                rAccessor: rAccessor,
                multiAxis: multiAxis
            }), allData = _e.allData, multiExtents = _e.multiExtents;
            var arrayWrappedAxis;
            if (Array.isArray(baseAxis)) {
                arrayWrappedAxis = baseAxis;
            }
            else if (baseAxis) {
                arrayWrappedAxis = [baseAxis];
            }
            if (multiExtents && baseAxis) {
                arrayWrappedAxis.forEach(function (d, i) {
                    d.extentOverride = multiExtents[i];
                });
            }
            var margin = frameFunctions_1.calculateMargin({
                margin: baseMargin,
                axes: arrayWrappedAxis,
                title: title,
                oLabel: oLabel,
                projection: projection
            });
            var _f = frameFunctions_1.adjustedPositionSize({
                size: size,
                margin: margin,
                projection: projection
            }), adjustedPosition = _f.adjustedPosition, adjustedSize = _f.adjustedSize;
            var oExtentSettings = baseOExtent === undefined || Array.isArray(baseOExtent)
                ? { extent: baseOExtent }
                : baseOExtent;
            var calculatedOExtent = allData.reduce(function (p, c) {
                var baseOValue = c.column;
                var oValue = baseOValue !== undefined ? String(baseOValue) : baseOValue;
                if (p.indexOf(oValue) === -1) {
                    p.push(oValue);
                }
                return p;
            }, []);
            var oExtent = oExtentSettings.extent || calculatedOExtent;
            if (pieceType.type === "barpercent") {
                var oExtentSums_1 = oExtent
                    .map(function (d) {
                    return allData
                        .filter(function (p) { return String(p.column) === d; })
                        .reduce(function (p, c) { return p + c.value; }, 0);
                })
                    .reduce(function (p, c, i) {
                    p[oExtent[i]] = c;
                    return p;
                }, {});
                allData.forEach(function (d) {
                    d.value =
                        (oExtentSums_1[d.column] && d.value / oExtentSums_1[d.column]) || 0;
                });
                pieceType.type = "bar";
            }
            if (pixelColumnWidth) {
                if (projection === "radial") {
                    console.error("pixelColumnWidth is not honored in radial mode");
                }
                else if (projection === "vertical") {
                    var sizeOffset = size[0] - adjustedSize[0];
                    adjustedSize[0] = oExtent.length * pixelColumnWidth;
                    size[0] = adjustedSize[0] + sizeOffset;
                }
                else {
                    var sizeOffset = size[1] - adjustedSize[1];
                    adjustedSize[1] = oExtent.length * pixelColumnWidth;
                    size[1] = adjustedSize[1] + sizeOffset;
                }
            }
            var oDomain = (projection === "vertical" && [0, adjustedSize[0]]) || [
                0,
                adjustedSize[1]
            ];
            var cwHash = oExtent.reduce(function (p, c) {
                p[c] = (1 / oExtent.length) * oDomain[1];
                p.total += p[c];
                return p;
            }, { total: 0 });
            var castOScaleType = oScaleType;
            var oScale = dynamicColumnWidth ? d3_scale_1.scaleOrdinal() : castOScaleType();
            oScale.domain(oExtent);
            var maxColumnValues;
            if (dynamicColumnWidth) {
                var columnValueCreator_1;
                if (typeof dynamicColumnWidth === "string") {
                    columnValueCreator_1 = function (d) { return d3_array_1.sum(d.map(function (p) { return p.data[dynamicColumnWidth]; })); };
                }
                else {
                    columnValueCreator_1 = function (d) { return dynamicColumnWidth(d.map(function (p) { return p.data; })); };
                }
                var thresholdDomain_1 = [0];
                maxColumnValues = 0;
                var columnValues_1 = [];
                oExtent.forEach(function (d) {
                    var oValues = allData.filter(function (p) { return p.column === d; });
                    var columnValue = columnValueCreator_1(oValues);
                    columnValues_1.push(columnValue);
                    maxColumnValues += columnValue;
                });
                cwHash.total = 0;
                oExtent.forEach(function (d, i) {
                    var oValue = columnValues_1[i];
                    var stepValue = (oValue / maxColumnValues) * (oDomain[1] - oDomain[0]);
                    cwHash[d] = stepValue;
                    cwHash.total += stepValue;
                    if (i !== oExtent.length - 1) {
                        thresholdDomain_1.push(stepValue + thresholdDomain_1[i]);
                    }
                });
                oScale.range(thresholdDomain_1);
            }
            else {
                oScale.range(oDomain);
            }
            var rExtentSettings = baseRExtent === undefined || Array.isArray(baseRExtent)
                ? { extent: baseRExtent, onChange: undefined }
                : baseRExtent;
            var rExtent = rExtentSettings.extent;
            var subZeroRExtent = [0, 0];
            if (pieceType.type === "bar" &&
                summaryType.type &&
                summaryType.type !== "none") {
                pieceType.type = "none";
            }
            if (pieceType.type === "timeline") {
                var rData = allData.map(function (d) { return d.value; });
                var leftExtent = d3_array_1.extent(rData.map(function (d) { return d[0]; }));
                var rightExtent = d3_array_1.extent(rData.map(function (d) { return d[1]; }));
                rExtent = d3_array_1.extent(__spread(leftExtent, rightExtent));
            }
            else if (pieceType.type !== "bar") {
                rExtent = d3_array_1.extent(allData, function (d) { return d.value; });
            }
            else {
                var positiveData = allData.filter(function (d) { return d.value >= 0; });
                var negativeData = allData.filter(function (d) { return d.value < 0; });
                var nestedPositiveData = d3_collection_1.nest()
                    .key(function (d) { return d.column; })
                    .rollup(function (leaves) { return d3_array_1.sum(leaves.map(function (d) { return d.value; })); })
                    .entries(positiveData);
                var nestedNegativeData = d3_collection_1.nest()
                    .key(function (d) { return d.column; })
                    .rollup(function (leaves) { return d3_array_1.sum(leaves.map(function (d) { return d.value; })); })
                    .entries(negativeData);
                rExtent = [
                    0,
                    nestedPositiveData.length === 0
                        ? 0
                        : Math.max(d3_array_1.max(nestedPositiveData, function (d) { return d.value; }), 0)
                ];
                subZeroRExtent = [
                    0,
                    nestedNegativeData.length === 0
                        ? 0
                        : Math.min(d3_array_1.min(nestedNegativeData, function (d) { return d.value; }), 0)
                ];
                rExtent = [subZeroRExtent[1], rExtent[1]];
            }
            if ((pieceType.type === "clusterbar" || multiAxis) && rExtent[0] > 0) {
                rExtent[0] = 0;
            }
            var calculatedRExtent = rExtent;
            if (rExtentSettings.extent &&
                rExtentSettings.extent[0] !== undefined &&
                rExtentSettings.extent[1] !== undefined) {
                rExtent = rExtentSettings.extent;
            }
            else {
                if (rExtentSettings.extent &&
                    rExtentSettings.extent[1] !== undefined &&
                    rExtentSettings.extent[0] === undefined) {
                    rExtent[1] = rExtentSettings.extent[1];
                }
                if (rExtentSettings.extent &&
                    rExtentSettings.extent[0] !== undefined &&
                    rExtentSettings.extent[1] === undefined) {
                    rExtent[0] = rExtentSettings.extent[0];
                }
            }
            if (currentProps.invertR ||
                (rExtentSettings.extent &&
                    rExtentSettings.extent[0] > rExtentSettings.extent[1])) {
                rExtent = [rExtent[1], rExtent[0]];
            }
            var nestedPieces = {};
            d3_collection_1.nest()
                .key(function (d) { return d.column; })
                .entries(allData)
                .forEach(function (d) {
                nestedPieces[d.key] = d.values;
            });
            if (sortO !== undefined) {
                oExtent = oExtent.sort(function (a, b) {
                    return sortO(a, b, nestedPieces[a].map(function (d) { return d.data; }), nestedPieces[b].map(function (d) { return d.data; }));
                });
                oScale.domain(oExtent);
            }
            var rDomain = (projection === "vertical" && [0, adjustedSize[1]]) || [
                0,
                adjustedSize[0]
            ];
            var castRScaleType = rScaleType;
            var instantiatedRScaleType = rScaleType.domain
                ? rScaleType
                : castRScaleType();
            var rScale = instantiatedRScaleType
                .copy()
                .domain(rExtent)
                .range(rDomain);
            var rScaleReverse = instantiatedRScaleType
                .copy()
                .domain(rDomain)
                .range(rDomain.reverse());
            var rScaleVertical = instantiatedRScaleType
                .copy()
                .domain(rExtent)
                .range(rDomain);
            var columnWidth = cwHash ? 0 : oScale.bandwidth();
            var pieceData = [];
            var mappedMiddleSize = adjustedSize[1];
            if (projection === "vertical") {
                mappedMiddleSize = adjustedSize[0];
            }
            var mappedMiddles = _this.mappedMiddles(oScale, mappedMiddleSize, padding);
            pieceData = oExtent.map(function (d) { return (nestedPieces[d] ? nestedPieces[d] : []); });
            var zeroValue = projection === "vertical" ? rScaleReverse(rScale(0)) : rScale(0);
            oExtent.forEach(function (o, i) {
                projectedColumns[o] = {
                    name: o,
                    padding: padding,
                    pieceData: pieceData[i],
                    pieces: pieceData[i]
                };
                projectedColumns[o].x = oScale(o) + padding / 2;
                projectedColumns[o].y = 0;
                projectedColumns[o].middle = mappedMiddles[o] + padding / 2;
                var negativeOffset = zeroValue;
                var positiveOffset = zeroValue;
                var negativeBaseValue = 0;
                var positiveBaseValue = 0;
                projectedColumns[o].pieceData.forEach(function (piece) {
                    var valPosition;
                    if (pieceType.type === "timeline") {
                        piece.scaledValue = rScale(piece.value[0]);
                        piece.scaledEndValue = rScale(piece.value[1]);
                        piece.scaledVerticalValue = rScaleVertical(piece.value[0]);
                    }
                    else if (pieceType.type !== "bar" &&
                        pieceType.type !== "clusterbar") {
                        piece.scaledValue = rScale(piece.value);
                        piece.scaledVerticalValue = rScaleVertical(piece.value);
                    }
                    else if (pieceType.type === "clusterbar") {
                        valPosition =
                            projection === "vertical"
                                ? rScaleReverse(rScale(piece.value))
                                : rScale(piece.value);
                        piece.scaledValue = Math.abs(zeroValue - valPosition);
                    }
                    piece.x = projectedColumns[o].x;
                    if (piece.value >= 0) {
                        if (pieceType.type === "bar") {
                            piece.scaledValue =
                                projection === "vertical"
                                    ? positiveOffset -
                                        rScaleReverse(rScale(positiveBaseValue + piece.value))
                                    : rScale(positiveBaseValue + piece.value) - positiveOffset;
                            positiveBaseValue += piece.value;
                        }
                        piece.base = zeroValue;
                        piece.bottom = pieceType.type === "bar" ? positiveOffset : 0;
                        piece.middle = piece.scaledValue / 2 + positiveOffset;
                        positiveOffset =
                            projection === "vertical"
                                ? positiveOffset - piece.scaledValue
                                : positiveOffset + piece.scaledValue;
                        piece.negative = false;
                    }
                    else {
                        if (pieceType.type === "bar") {
                            piece.scaledValue =
                                projection === "vertical"
                                    ? negativeOffset -
                                        rScaleReverse(rScale(negativeBaseValue - piece.value))
                                    : rScale(negativeBaseValue - piece.value) - negativeOffset;
                            negativeBaseValue += piece.value;
                        }
                        piece.base = zeroValue;
                        piece.bottom = pieceType.type === "bar" ? negativeOffset : 0;
                        piece.middle = negativeOffset - piece.scaledValue / 2;
                        negativeOffset =
                            projection === "vertical"
                                ? negativeOffset + piece.scaledValue
                                : negativeOffset - piece.scaledValue;
                        piece.negative = true;
                    }
                });
                if (cwHash) {
                    projectedColumns[o].width = cwHash[o] - padding;
                    if (currentProps.ordinalAlign === "center") {
                        if (i === 0) {
                            projectedColumns[o].x =
                                projectedColumns[o].x - projectedColumns[o].width / 2;
                            projectedColumns[o].middle =
                                projectedColumns[o].middle - projectedColumns[o].width / 2;
                        }
                        else {
                            projectedColumns[o].x =
                                projectedColumns[oExtent[i - 1]].x +
                                    projectedColumns[oExtent[i - 1]].width;
                            projectedColumns[o].middle =
                                projectedColumns[o].x + projectedColumns[o].width / 2;
                        }
                    }
                    projectedColumns[o].pct = cwHash[o] / cwHash.total;
                    projectedColumns[o].pct_start =
                        (projectedColumns[o].x - oDomain[0]) / cwHash.total;
                    projectedColumns[o].pct_padding = padding / cwHash.total;
                    projectedColumns[o].pct_middle =
                        (projectedColumns[o].middle - oDomain[0]) / cwHash.total;
                }
                else {
                    projectedColumns[o].width = columnWidth - padding;
                    if (currentProps.ordinalAlign === "center") {
                        projectedColumns[o].x =
                            projectedColumns[o].x - projectedColumns[o].width / 2;
                        projectedColumns[o].middle =
                            projectedColumns[o].middle - projectedColumns[o].width / 2;
                    }
                    projectedColumns[o].pct = columnWidth / adjustedSize[1];
                    projectedColumns[o].pct_start =
                        (projectedColumns[o].x - oDomain[0]) / adjustedSize[1];
                    projectedColumns[o].pct_padding = padding / adjustedSize[1];
                    projectedColumns[o].pct_middle =
                        (projectedColumns[o].middle - oDomain[0]) / adjustedSize[1];
                }
            });
            var labelArray = [];
            var pieArcs = [];
            var labelSettings = typeof oLabel === "object"
                ? Object.assign({ label: true, padding: 5 }, oLabel)
                : { orient: "default", label: oLabel, padding: 5 };
            if (oLabel || hoverAnnotation) {
                var offsetPct_1 = (pieceType.offsetAngle && pieceType.offsetAngle / 360) || 0;
                var rangePct = (pieceType.angleRange &&
                    pieceType.angleRange.map(function (d) { return d / 360; })) || [0, 1];
                var rangeMod_1 = rangePct[1] - rangePct[0];
                var adjustedPct_1 = rangeMod_1 < 1
                    ? d3_scale_1.scaleLinear()
                        .domain([0, 1])
                        .range(rangePct)
                    : function (d) { return d; };
                oExtent.forEach(function (d) {
                    var arcGenerator = d3_shape_1.arc()
                        .innerRadius(0)
                        .outerRadius(rScale.range()[1] / 2);
                    var angle = projectedColumns[d].pct * rangeMod_1;
                    var startAngle = adjustedPct_1(projectedColumns[d].pct_start + offsetPct_1);
                    var endAngle = startAngle + angle;
                    var midAngle = startAngle + angle / 2;
                    var markD = arcGenerator({
                        startAngle: startAngle * twoPI,
                        endAngle: endAngle * twoPI
                    });
                    var translate = [adjustedSize[0] / 2, adjustedSize[1] / 2];
                    var centroid = arcGenerator.centroid({
                        startAngle: startAngle * twoPI,
                        endAngle: endAngle * twoPI
                    });
                    var addedPadding = centroid[1] > 0 &&
                        (!labelSettings.orient ||
                            labelSettings.orient === "default" ||
                            labelSettings.orient === "edge")
                        ? 8
                        : 0;
                    var outerPoint = pieceDrawing_1.pointOnArcAtAngle([0, 0], midAngle, rScale.range()[1] / 2 + labelSettings.padding + addedPadding);
                    pieArcs.push({
                        startAngle: startAngle,
                        endAngle: endAngle,
                        midAngle: midAngle,
                        markD: markD,
                        translate: translate,
                        centroid: centroid,
                        outerPoint: outerPoint
                    });
                });
            }
            if (currentProps.oLabel) {
                var labelingFn_1;
                if (labelSettings.label === true) {
                    var labelStyle_1 = {
                        textAnchor: "middle"
                    };
                    if (projection === "horizontal" && labelSettings.orient === "right") {
                        labelStyle_1.textAnchor = "start";
                    }
                    else if (projection === "horizontal") {
                        labelStyle_1.textAnchor = "end";
                    }
                    labelingFn_1 = function (d, p, i) {
                        var additionalStyle = {};
                        var transformRotate;
                        if (projection === "radial" && labelSettings.orient === "stem") {
                            transformRotate = "rotate(" + (pieArcs[i].outerPoint[0] < 0
                                ? pieArcs[i].midAngle * 360 + 90
                                : pieArcs[i].midAngle * 360 - 90) + ")";
                        }
                        else if (projection === "radial" &&
                            labelSettings.orient !== "center") {
                            transformRotate = "rotate(" + (pieArcs[i].outerPoint[1] < 0
                                ? pieArcs[i].midAngle * 360
                                : pieArcs[i].midAngle * 360 + 180) + ")";
                        }
                        if (projection === "radial" &&
                            labelSettings.orient === "stem" &&
                            ((pieArcs[i].outerPoint[0] > 0 && labelSettings.padding < 0) ||
                                (pieArcs[i].outerPoint[0] < 0 && labelSettings.padding >= 0))) {
                            additionalStyle.textAnchor = "end";
                        }
                        else if (projection === "radial" &&
                            labelSettings.orient === "stem") {
                            additionalStyle.textAnchor = "start";
                        }
                        return (React.createElement("text", __assign({}, labelStyle_1, additionalStyle, { transform: transformRotate }), d));
                    };
                }
                else if (typeof labelSettings.label === "function") {
                    labelingFn_1 = labelSettings.label;
                }
                oExtent.forEach(function (d, i) {
                    var xPosition = projectedColumns[d].middle;
                    var yPosition = 0;
                    if (projection === "horizontal") {
                        yPosition = projectedColumns[d].middle;
                        if (labelSettings.orient === "right") {
                            xPosition = adjustedSize[0] + 3;
                        }
                        else {
                            xPosition = -3;
                        }
                    }
                    else if (projection === "radial") {
                        if (labelSettings.orient === "center") {
                            xPosition = pieArcs[i].centroid[0] + pieArcs[i].translate[0];
                            yPosition = pieArcs[i].centroid[1] + pieArcs[i].translate[1];
                        }
                        else {
                            xPosition = pieArcs[i].outerPoint[0] + pieArcs[i].translate[0];
                            yPosition = pieArcs[i].outerPoint[1] + pieArcs[i].translate[1];
                        }
                    }
                    var label = labelingFn_1(d, projectedColumns[d].pieceData.map(function (d) { return d.data; }), i
                    //          ,{ arc: pieArcs[i], data: projectedColumns[d] }
                    );
                    labelArray.push(React.createElement("g", { key: "olabel-" + i, transform: "translate(" + xPosition + "," + yPosition + ")" }, label));
                });
                if (projection === "vertical") {
                    var labelY = void 0;
                    if (labelSettings.orient === "top") {
                        labelY = -15;
                    }
                    else {
                        labelY = 15 + rScale.range()[1];
                    }
                    oLabels = (React.createElement("g", { key: "ordinalframe-labels-container", className: "ordinal-labels", transform: "translate(" + margin.left + "," + (labelY + margin.top) + ")" }, labelArray));
                }
                else if (projection === "horizontal") {
                    oLabels = (React.createElement("g", { key: "ordinalframe-labels-container", className: "ordinal-labels", transform: "translate(" + margin.left + "," + margin.top + ")" }, labelArray));
                }
                else if (projection === "radial") {
                    oLabels = (React.createElement("g", { key: "ordinalframe-labels-container", className: "ordinal-labels", transform: "translate(" + margin.left + "," + margin.top + ")" }, labelArray));
                }
            }
            var columnOverlays;
            if (currentProps.hoverAnnotation) {
                columnOverlays = oExtent.map(function (d, i) {
                    var barColumnWidth = projectedColumns[d].width;
                    var xPosition = projectedColumns[d].x;
                    var yPosition = 0;
                    var height = rScale.range()[1];
                    var width = barColumnWidth + padding;
                    if (projection === "horizontal") {
                        yPosition = projectedColumns[d].x;
                        xPosition = 0;
                        width = rScale.range()[1];
                        height = barColumnWidth;
                    }
                    if (projection === "radial") {
                        var _a = pieArcs[i], markD = _a.markD, centroid = _a.centroid, translate = _a.translate, midAngle = _a.midAngle;
                        var radialMousePackage_1 = {
                            type: "column-hover",
                            column: projectedColumns[d],
                            pieces: projectedColumns[d].pieceData,
                            summary: projectedColumns[d].pieceData,
                            arcAngles: {
                                centroid: centroid,
                                translate: translate,
                                midAngle: midAngle,
                                length: rScale.range()[1] / 2
                            }
                        };
                        return {
                            markType: "path",
                            key: "hover" + d,
                            d: markD,
                            transform: "translate(" + translate.join(",") + ")",
                            style: { opacity: 0, fill: "pink" },
                            overlayData: radialMousePackage_1,
                            onDoubleClick: customDoubleClickBehavior &&
                                (function () {
                                    customDoubleClickBehavior(radialMousePackage_1);
                                }),
                            onClick: customClickBehavior &&
                                (function () {
                                    customClickBehavior(radialMousePackage_1);
                                }),
                            onMouseEnter: customHoverBehavior &&
                                (function () {
                                    customHoverBehavior(radialMousePackage_1);
                                }),
                            onMouseLeave: customHoverBehavior &&
                                (function () {
                                    customHoverBehavior();
                                })
                        };
                    }
                    var baseMousePackage = {
                        type: "column-hover",
                        column: projectedColumns[d],
                        pieces: projectedColumns[d].pieceData,
                        summary: projectedColumns[d].pieceData
                    };
                    return {
                        markType: "rect",
                        key: "hover-" + d,
                        x: xPosition,
                        y: yPosition,
                        height: height,
                        width: width,
                        style: { opacity: 0, stroke: "black", fill: "pink" },
                        onDoubleClick: customDoubleClickBehavior &&
                            (function () {
                                customDoubleClickBehavior(baseMousePackage);
                            }),
                        onClick: customClickBehavior &&
                            (function () {
                                customClickBehavior(baseMousePackage);
                            }),
                        onMouseEnter: customHoverBehavior &&
                            (function () {
                                customHoverBehavior(baseMousePackage);
                            }),
                        onMouseLeave: function () { return ({}); },
                        overlayData: baseMousePackage
                    };
                });
            }
            var _g = frameFunctions_1.orFrameAxisGenerator({
                axis: arrayWrappedAxis,
                data: allData,
                projection: projection,
                adjustedSize: adjustedSize,
                size: size,
                rScale: rScale,
                rScaleType: instantiatedRScaleType.copy(),
                pieceType: pieceType,
                rExtent: rExtent,
                maxColumnValues: maxColumnValues
            }), axis = _g.axis, axesTickLines = _g.axesTickLines;
            var renderMode = currentProps.renderMode, canvasSummaries = currentProps.canvasSummaries, summaryRenderMode = currentProps.summaryRenderMode, connectorClass = currentProps.connectorClass, connectorRenderMode = currentProps.connectorRenderMode, canvasConnectors = currentProps.canvasConnectors, canvasPieces = currentProps.canvasPieces;
            var pieceDataXY;
            var pieceRenderMode = dataFunctions_1.stringToFn(renderMode, undefined, true);
            var pieceCanvasRender = dataFunctions_1.stringToFn(canvasPieces, undefined, true);
            var summaryCanvasRender = dataFunctions_1.stringToFn(canvasSummaries, undefined, true);
            var connectorCanvasRender = dataFunctions_1.stringToFn(canvasConnectors, undefined, true);
            var pieceTypeForXY = pieceType.type && pieceType.type !== "none" ? pieceType.type : "point";
            var pieceTypeLayout = typeof pieceTypeForXY === "function"
                ? pieceTypeForXY
                : layoutHash[pieceTypeForXY];
            var calculatedPieceData = pieceTypeLayout({
                type: pieceType,
                data: projectedColumns,
                renderMode: pieceRenderMode,
                eventListenersGenerator: eventListenersGenerator,
                styleFn: pieceStyle,
                projection: projection,
                classFn: pieceClass,
                adjustedSize: adjustedSize,
                chartSize: size,
                margin: margin,
                rScale: rScale,
                baseMarkProps: baseMarkProps
            });
            var keyedData = calculatedPieceData.reduce(function (p, c) {
                if (!p[c.o]) {
                    p[c.o] = [];
                }
                p[c.o].push(c);
                return p;
            }, {});
            Object.keys(projectedColumns).forEach(function (d) {
                projectedColumns[d].xyData = keyedData[d] || [];
            });
            var calculatedSummaries = {};
            if (summaryType.type && summaryType.type !== "none") {
                calculatedSummaries = summaryLayouts_1.drawSummaries({
                    data: projectedColumns,
                    type: summaryType,
                    renderMode: dataFunctions_1.stringToFn(summaryRenderMode, undefined, true),
                    styleFn: dataFunctions_1.stringToFn(summaryStyle, function () { return ({}); }, true),
                    classFn: dataFunctions_1.stringToFn(summaryClass, function () { return ""; }, true),
                    //        canvasRender: stringToFn<boolean>(canvasSummaries, undefined, true),
                    positionFn: summaryPosition,
                    projection: projection,
                    eventListenersGenerator: eventListenersGenerator,
                    adjustedSize: adjustedSize,
                    baseMarkProps: baseMarkProps,
                    //        chartSize: size,
                    margin: margin
                });
                calculatedSummaries.originalData = projectedColumns;
            }
            if ((pieceHoverAnnotation &&
                ["bar", "clusterbar", "timeline"].indexOf(pieceType.type) === -1) ||
                summaryHoverAnnotation) {
                var yMod_1 = projection === "horizontal" ? midMod : zeroFunction;
                var xMod_1 = projection === "vertical" ? midMod : zeroFunction;
                if (summaryHoverAnnotation && calculatedSummaries.xyPoints) {
                    pieceDataXY = calculatedSummaries.xyPoints.map(function (d) {
                        return Object.assign({}, d, {
                            type: "frame-hover",
                            isSummaryData: true,
                            x: d.x,
                            y: d.y
                        });
                    });
                }
                else if (pieceHoverAnnotation && calculatedPieceData) {
                    pieceDataXY = calculatedPieceData.map(function (d) {
                        return Object.assign({}, d.piece, {
                            type: "frame-hover",
                            x: d.xy.x + xMod_1(d.xy),
                            y: d.xy.y + yMod_1(d.xy)
                        });
                    });
                }
            }
            if (pieceHoverAnnotation &&
                ["bar", "clusterbar", "timeline"].indexOf(pieceType.type) !== -1) {
                var yMod_2 = projection === "horizontal" ? midMod : zeroFunction;
                var xMod_2 = projection === "vertical" ? midMod : zeroFunction;
                columnOverlays = calculatedPieceData.map(function (d, i) {
                    var mousePackage = __assign({}, d.piece, { x: d.xy.x + xMod_2(d.xy), y: d.xy.y + yMod_2(d.xy) });
                    if (React.isValidElement(d.renderElement)) {
                        return {
                            renderElement: d.renderElement,
                            overlayData: mousePackage
                        };
                    }
                    return __assign({}, d.renderElement, { key: "hover-" + i, type: "frame-hover", style: { opacity: 0, stroke: "black", fill: "pink" }, overlayData: mousePackage, onClick: customClickBehavior &&
                            (function () {
                                customClickBehavior(mousePackage.data);
                            }), onDoubleClick: customDoubleClickBehavior &&
                            (function () {
                                customDoubleClickBehavior(mousePackage.data);
                            }), onMouseEnter: customHoverBehavior &&
                            (function () {
                                customHoverBehavior(mousePackage.data);
                            }), onMouseLeave: customHoverBehavior &&
                            (function () {
                                customHoverBehavior();
                            }) });
                });
            }
            var typeAriaLabel = (pieceType.type !== undefined &&
                typeof pieceType.type !== "function" &&
                naturalLanguageTypes[pieceType.type]) || {
                items: "piece",
                chart: "ordinal chart"
            };
            var orFrameRender = {
                connectors: {
                    accessibleTransform: function (data, i) { return data[i]; },
                    projection: projection,
                    data: keyedData,
                    styleFn: dataFunctions_1.stringToFn(connectorStyle, function () { return ({}); }, true),
                    classFn: dataFunctions_1.stringToFn(connectorClass, function () { return ""; }, true),
                    renderMode: dataFunctions_1.stringToFn(connectorRenderMode, undefined, true),
                    canvasRender: connectorCanvasRender,
                    behavior: frameFunctions_1.orFrameConnectionRenderer,
                    type: connectorType,
                    eventListenersGenerator: eventListenersGenerator,
                    pieceType: pieceType
                },
                summaries: {
                    accessibleTransform: function (data, i) {
                        var columnName = oExtent[i];
                        var summaryPackage = {
                            type: "column-hover",
                            column: projectedColumns[columnName],
                            pieces: projectedColumns[columnName].pieceData,
                            summary: projectedColumns[columnName].pieceData,
                            oAccessor: oAccessor
                        };
                        return summaryPackage;
                    },
                    data: calculatedSummaries.marks,
                    behavior: summaryLayouts_1.renderLaidOutSummaries,
                    canvasRender: summaryCanvasRender,
                    styleFn: dataFunctions_1.stringToFn(summaryStyle, function () { return ({}); }, true),
                    classFn: dataFunctions_1.stringToFn(summaryClass, function () { return ""; }, true)
                },
                pieces: {
                    accessibleTransform: function (data, i) { return (__assign({}, (data[i].piece ? __assign({}, data[i].piece, data[i].xy) : data[i]), { type: "frame-hover" })); },
                    shouldRender: pieceType.type && pieceType.type !== "none",
                    data: calculatedPieceData,
                    behavior: pieceDrawing_1.renderLaidOutPieces,
                    canvasRender: pieceCanvasRender,
                    styleFn: dataFunctions_1.stringToFn(pieceStyle, function () { return ({}); }, true),
                    classFn: dataFunctions_1.stringToFn(pieceClass, function () { return ""; }, true),
                    axis: arrayWrappedAxis,
                    ariaLabel: typeAriaLabel
                }
            };
            if (rExtentSettings.onChange &&
                (_this.state.calculatedRExtent || []).join(",") !==
                    (calculatedRExtent || []).join(",")) {
                rExtentSettings.onChange(calculatedRExtent);
            }
            if (oExtentSettings.onChange &&
                (_this.state.calculatedOExtent || []).join(",") !==
                    (calculatedOExtent || []).join(",")) {
                oExtentSettings.onChange(calculatedOExtent);
            }
            _this.setState({
                pieceDataXY: pieceDataXY,
                adjustedPosition: adjustedPosition,
                adjustedSize: adjustedSize,
                backgroundGraphics: backgroundGraphics,
                foregroundGraphics: foregroundGraphics,
                axisData: arrayWrappedAxis,
                axes: axis,
                axesTickLines: axesTickLines,
                oLabels: oLabels,
                title: title,
                columnOverlays: columnOverlays,
                renderNumber: _this.state.renderNumber + 1,
                oAccessor: oAccessor,
                rAccessor: rAccessor,
                oScaleType: oScaleType,
                rScaleType: instantiatedRScaleType,
                oExtent: oExtent,
                rExtent: rExtent,
                oScale: oScale,
                rScale: rScale,
                calculatedOExtent: calculatedOExtent,
                calculatedRExtent: calculatedRExtent,
                projectedColumns: projectedColumns,
                margin: margin,
                legendSettings: legend,
                orFrameRender: orFrameRender,
                summaryType: summaryType,
                type: pieceType,
                pieceIDAccessor: pieceIDAccessor
            });
        };
        _this.defaultORSVGRule = function (_a) {
            var d = _a.d, i = _a.i, annotationLayer = _a.annotationLayer;
            var projection = _this.props.projection;
            var _b = _this.state, adjustedPosition = _b.adjustedPosition, adjustedSize = _b.adjustedSize, oAccessor = _b.oAccessor, rAccessor = _b.rAccessor, oScale = _b.oScale, rScale = _b.rScale, projectedColumns = _b.projectedColumns, orFrameRender = _b.orFrameRender, pieceIDAccessor = _b.pieceIDAccessor, rScaleType = _b.rScaleType;
            var screenCoordinates = [0, 0];
            //TODO: Support radial??
            if (d.coordinates || (d.type === "enclose" && d.neighbors)) {
                screenCoordinates = (d.coordinates || d.neighbors).map(function (p) {
                    var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, p) || p.column;
                    var oColumn = projectedColumns[pO];
                    var idPiece = orframeRules_1.findIDPiece(pieceIDAccessor, oColumn, p);
                    return orframeRules_1.screenProject({
                        p: p,
                        adjustedSize: adjustedSize,
                        rScale: rScale,
                        rAccessor: rAccessor,
                        idPiece: idPiece,
                        projection: projection,
                        oColumn: oColumn,
                        rScaleType: rScaleType
                    });
                });
            }
            else {
                var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, d) || d.column;
                var oColumn = projectedColumns[pO];
                var idPiece = orframeRules_1.findIDPiece(pieceIDAccessor, oColumn, d);
                screenCoordinates = orframeRules_1.screenProject({
                    p: d,
                    adjustedSize: adjustedSize,
                    rScale: rScale,
                    rAccessor: rAccessor,
                    idPiece: idPiece,
                    projection: projection,
                    oColumn: oColumn,
                    rScaleType: rScaleType
                });
            }
            var voronoiHover = annotationLayer.voronoiHover;
            //TODO: Process your rules first
            var customAnnotation = _this.props.svgAnnotationRules &&
                _this.props.svgAnnotationRules({
                    d: d,
                    i: i,
                    oScale: oScale,
                    rScale: rScale,
                    oAccessor: oAccessor,
                    rAccessor: rAccessor,
                    orFrameProps: _this.props,
                    orFrameState: _this.state,
                    screenCoordinates: screenCoordinates,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer,
                    categories: _this.state.projectedColumns,
                    voronoiHover: voronoiHover
                });
            if (_this.props.svgAnnotationRules && customAnnotation !== null) {
                return customAnnotation;
            }
            else if (d.type === "desaturation-layer") {
                return baseRules_1.desaturationLayer({
                    style: d.style instanceof Function ? d.style(d, i) : d.style,
                    size: adjustedSize,
                    i: i,
                    key: d.key
                });
            }
            else if (d.type === "ordinal-line") {
                return orframeRules_1.svgOrdinalLine({ d: d, screenCoordinates: screenCoordinates, voronoiHover: voronoiHover });
            }
            else if (d.type === "or") {
                return orframeRules_1.svgORRule({ d: d, i: i, screenCoordinates: screenCoordinates, projection: projection });
            }
            else if (d.type === "highlight") {
                return orframeRules_1.svgHighlightRule({
                    d: d,
                    pieceIDAccessor: pieceIDAccessor,
                    orFrameRender: orFrameRender,
                    oAccessor: oAccessor
                });
            }
            else if (d.type === "react-annotation" || typeof d.type === "function") {
                return orframeRules_1.basicReactAnnotationRule({ d: d, i: i, screenCoordinates: screenCoordinates });
            }
            else if (d.type === "enclose") {
                return orframeRules_1.svgEncloseRule({ d: d, i: i, screenCoordinates: screenCoordinates });
            }
            else if (d.type === "enclose-rect") {
                return orframeRules_1.svgRectEncloseRule({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "r") {
                return orframeRules_1.svgRRule({
                    d: d,
                    i: i,
                    screenCoordinates: screenCoordinates,
                    rScale: rScale,
                    rAccessor: rAccessor,
                    projection: projection,
                    adjustedSize: adjustedSize,
                    adjustedPosition: adjustedPosition
                });
            }
            else if (d.type === "category") {
                return orframeRules_1.svgCategoryRule({
                    projection: projection,
                    d: d,
                    i: i,
                    categories: _this.state.projectedColumns,
                    adjustedSize: adjustedSize
                });
            }
            return null;
        };
        _this.defaultORHTMLRule = function (_a) {
            var d = _a.d, i = _a.i, annotationLayer = _a.annotationLayer;
            var _b = _this.state, adjustedPosition = _b.adjustedPosition, adjustedSize = _b.adjustedSize, oAccessor = _b.oAccessor, rAccessor = _b.rAccessor, oScale = _b.oScale, rScale = _b.rScale, projectedColumns = _b.projectedColumns, summaryType = _b.summaryType, type = _b.type, pieceIDAccessor = _b.pieceIDAccessor, rScaleType = _b.rScaleType;
            var _c = _this.props, htmlAnnotationRules = _c.htmlAnnotationRules, tooltipContent = _c.tooltipContent, projection = _c.projection, size = _c.size, useSpans = _c.useSpans;
            var screenCoordinates = [0, 0];
            var voronoiHover = annotationLayer.voronoiHover;
            if (d.coordinates || (d.type === "enclose" && d.neighbors)) {
                screenCoordinates = (d.coordinates || d.neighbors).map(function (p) {
                    var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, p) || p.column;
                    var oColumn = projectedColumns[pO];
                    var idPiece = orframeRules_1.findIDPiece(pieceIDAccessor, oColumn, p);
                    return orframeRules_1.screenProject({
                        p: p,
                        adjustedSize: adjustedSize,
                        rScale: rScale,
                        rAccessor: rAccessor,
                        idPiece: idPiece,
                        projection: projection,
                        oColumn: oColumn,
                        rScaleType: rScaleType
                    });
                });
            }
            else if (d.type === "column-hover") {
                var _d = __read(orframeRules_1.getColumnScreenCoordinates({
                    d: d,
                    projectedColumns: projectedColumns,
                    oAccessor: oAccessor,
                    summaryType: summaryType,
                    type: type,
                    projection: projection,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize
                }).coordinates, 2), xPosition = _d[0], yPosition = _d[1];
                screenCoordinates = [xPosition, yPosition];
            }
            else {
                var pO = multiAccessorUtils_1.findFirstAccessorValue(oAccessor, d) || d.column;
                var oColumn = projectedColumns[pO];
                var idPiece = orframeRules_1.findIDPiece(pieceIDAccessor, oColumn, d);
                screenCoordinates = orframeRules_1.screenProject({
                    p: d,
                    adjustedSize: adjustedSize,
                    rScale: rScale,
                    rAccessor: rAccessor,
                    idPiece: idPiece,
                    projection: projection,
                    oColumn: oColumn,
                    rScaleType: rScaleType
                });
            }
            var flippedRScale = projection === "vertical"
                ? rScaleType.domain(rScale.domain()).range(rScale.range().reverse())
                : rScale;
            //TODO: Process your rules first
            var customAnnotation = htmlAnnotationRules &&
                htmlAnnotationRules({
                    d: d,
                    i: i,
                    oScale: oScale,
                    rScale: flippedRScale,
                    oAccessor: oAccessor,
                    rAccessor: rAccessor,
                    orFrameProps: _this.props,
                    screenCoordinates: screenCoordinates,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer,
                    orFrameState: _this.state,
                    categories: _this.state.projectedColumns,
                    voronoiHover: voronoiHover
                });
            if (htmlAnnotationRules && customAnnotation !== null) {
                return customAnnotation;
            }
            if (d.type === "frame-hover") {
                return orframeRules_1.htmlFrameHoverRule({
                    d: d,
                    i: i,
                    rAccessor: rAccessor,
                    oAccessor: oAccessor,
                    projection: projection,
                    tooltipContent: tooltipContent,
                    projectedColumns: projectedColumns,
                    useSpans: useSpans,
                    pieceIDAccessor: pieceIDAccessor,
                    adjustedSize: adjustedSize,
                    rScale: rScale,
                    type: type,
                    rScaleType: rScaleType
                });
            }
            else if (d.type === "column-hover") {
                return orframeRules_1.htmlColumnHoverRule({
                    d: d,
                    i: i,
                    summaryType: summaryType,
                    oAccessor: oAccessor,
                    projectedColumns: projectedColumns,
                    type: type,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    projection: projection,
                    tooltipContent: tooltipContent,
                    useSpans: useSpans
                });
            }
            return null;
        };
        _this.state = {
            adjustedPosition: [],
            adjustedSize: [],
            backgroundGraphics: undefined,
            foregroundGraphics: undefined,
            axisData: undefined,
            renderNumber: 0,
            oLabels: [],
            oAccessor: dataFunctions_1.stringToArrayFn("renderKey"),
            rAccessor: dataFunctions_1.stringToArrayFn("value"),
            oScale: d3_scale_1.scaleBand(),
            rScale: d3_scale_1.scaleLinear(),
            axes: undefined,
            calculatedOExtent: [],
            calculatedRExtent: [0, 1],
            columnOverlays: [],
            dataVersion: undefined,
            legendSettings: {},
            margin: { top: 0, bottom: 0, left: 0, right: 0 },
            oExtent: [],
            oScaleType: d3_scale_1.scaleBand(),
            orFrameRender: {},
            pieceDataXY: [],
            pieceIDAccessor: dataFunctions_1.stringToFn("semioticPieceID"),
            projectedColumns: {},
            rExtent: [],
            rScaleType: d3_scale_1.scaleLinear(),
            summaryType: { type: "none" },
            title: {},
            type: { type: "none" }
        };
        return _this;
    }
    OrdinalFrame.prototype.componentWillUnmount = function () {
        if (this.props.onUnmount) {
            this.props.onUnmount(this.props, this.state);
        }
    };
    OrdinalFrame.prototype.componentWillMount = function () {
        Object.keys(this.props).forEach(function (d) {
            if (!frame_props_1.ordinalframeproptypes[d]) {
                if (frame_props_1.xyframeproptypes[d]) {
                    console.error(d + " is an XYFrame prop are you sure you're using the right frame?");
                }
                else if (frame_props_1.networkframeproptypes[d]) {
                    console.error(d + " is a NetworkFrame prop are you sure you're using the right frame?");
                }
                else {
                    console.error(d + " is not a valid OrdinalFrame prop");
                }
            }
        });
        this.calculateOrdinalFrame(this.props);
    };
    OrdinalFrame.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        if ((this.state.dataVersion &&
            this.state.dataVersion !== nextProps.dataVersion) ||
            !this.state.projectedColumns) {
            this.calculateOrdinalFrame(nextProps);
        }
        else if (this.props.size[0] !== nextProps.size[0] ||
            this.props.size[1] !== nextProps.size[1] ||
            (!this.state.dataVersion &&
                frame_props_1.orFrameChangeProps.find(function (d) {
                    return _this.props[d] !== nextProps[d];
                }))) {
            this.calculateOrdinalFrame(nextProps);
        }
    };
    OrdinalFrame.prototype.mappedMiddles = function (oScale, middleMax, padding) {
        var oScaleDomainValues = oScale.domain();
        var mappedMiddles = {};
        oScaleDomainValues.forEach(function (p, q) {
            var base = oScale(p) - padding;
            var next = oScaleDomainValues[q + 1]
                ? oScale(oScaleDomainValues[q + 1])
                : middleMax;
            var diff = (next - base) / 2;
            mappedMiddles[p] = base + diff;
        });
        return mappedMiddles;
    };
    OrdinalFrame.prototype.render = function () {
        var _a = this.props, className = _a.className, annotationSettings = _a.annotationSettings, size = _a.size, downloadFields = _a.downloadFields, rAccessor = _a.rAccessor, oAccessor = _a.oAccessor, name = _a.name, download = _a.download, annotations = _a.annotations, matte = _a.matte, renderKey = _a.renderKey, interaction = _a.interaction, customClickBehavior = _a.customClickBehavior, customHoverBehavior = _a.customHoverBehavior, customDoubleClickBehavior = _a.customDoubleClickBehavior, projection = _a.projection, backgroundGraphics = _a.backgroundGraphics, foregroundGraphics = _a.foregroundGraphics, afterElements = _a.afterElements, beforeElements = _a.beforeElements, disableContext = _a.disableContext, summaryType = _a.summaryType, summaryHoverAnnotation = _a.summaryHoverAnnotation, pieceHoverAnnotation = _a.pieceHoverAnnotation, hoverAnnotation = _a.hoverAnnotation, canvasPostProcess = _a.canvasPostProcess, baseMarkProps = _a.baseMarkProps, useSpans = _a.useSpans, canvasPieces = _a.canvasPieces, canvasSummaries = _a.canvasSummaries, canvasConnectors = _a.canvasConnectors, renderOrder = _a.renderOrder, additionalDefs = _a.additionalDefs;
        var _b = this.state, orFrameRender = _b.orFrameRender, projectedColumns = _b.projectedColumns, adjustedPosition = _b.adjustedPosition, adjustedSize = _b.adjustedSize, legendSettings = _b.legendSettings, columnOverlays = _b.columnOverlays, axesTickLines = _b.axesTickLines, axes = _b.axes, axisData = _b.axisData, margin = _b.margin, pieceDataXY = _b.pieceDataXY, oLabels = _b.oLabels, title = _b.title;
        var downloadButton;
        if (download) {
            downloadButton = (React.createElement(DownloadButton_1.default, { csvName: (name || "orframe") + "-" + new Date().toJSON(), width: size[0], data: downloadDataMapping_1.orDownloadMapping({
                    data: projectedColumns,
                    rAccessor: dataFunctions_1.stringToArrayFn(rAccessor),
                    oAccessor: dataFunctions_1.stringToArrayFn(oAccessor),
                    fields: downloadFields
                }) }));
        }
        var interactionOverflow;
        if (summaryType && summaryType.amplitude) {
            if (projection === "horizontal") {
                interactionOverflow = {
                    top: summaryType.amplitude,
                    bottom: 0,
                    left: 0,
                    right: 0
                };
            }
            else if (projection === "radial") {
                interactionOverflow = defaultOverflow;
            }
            else {
                interactionOverflow = {
                    top: 0,
                    bottom: 0,
                    left: summaryType.amplitude,
                    right: 0
                };
            }
        }
        var renderedForegroundGraphics = typeof foregroundGraphics === "function"
            ? foregroundGraphics({ size: size, margin: margin })
            : foregroundGraphics;
        return (React.createElement(Frame_1.default, { name: "ordinalframe", renderPipeline: orFrameRender, adjustedPosition: adjustedPosition, adjustedSize: adjustedSize, size: size, xScale: xScale, yScale: yScale, axes: axes, useSpans: useSpans, axesTickLines: axesTickLines, title: title, matte: matte, additionalDefs: additionalDefs, className: className, frameKey: "none", renderFn: renderKey, projectedCoordinateNames: projectedCoordinatesObject, defaultSVGRule: this.defaultORSVGRule.bind(this), defaultHTMLRule: this.defaultORHTMLRule.bind(this), hoverAnnotation: summaryHoverAnnotation || pieceHoverAnnotation || hoverAnnotation, annotations: annotations, annotationSettings: annotationSettings, legendSettings: legendSettings, interaction: interaction && __assign({}, interaction, { brush: interaction.columnsBrush !== true && "oBrush", projection: projection,
                projectedColumns: projectedColumns }), customClickBehavior: customClickBehavior, customHoverBehavior: customHoverBehavior, customDoubleClickBehavior: customDoubleClickBehavior, points: pieceDataXY, margin: margin, columns: projectedColumns, backgroundGraphics: backgroundGraphics, foregroundGraphics: [renderedForegroundGraphics, oLabels], beforeElements: beforeElements, afterElements: afterElements, downloadButton: downloadButton, overlay: columnOverlays, rScale: this.state.rScale, projection: projection, disableContext: disableContext, interactionOverflow: interactionOverflow, canvasPostProcess: canvasPostProcess, baseMarkProps: baseMarkProps, canvasRendering: !!(canvasPieces || canvasSummaries || canvasConnectors), renderOrder: renderOrder, disableCanvasInteraction: true }));
    };
    OrdinalFrame.defaultProps = {
        annotations: [],
        foregroundGraphics: [],
        annotationSettings: {},
        projection: "vertical",
        size: [500, 500],
        className: "",
        data: [],
        oScaleType: d3_scale_1.scaleBand,
        rScaleType: d3_scale_1.scaleLinear,
        type: "none",
        summaryType: "none",
        useSpans: false
    };
    OrdinalFrame.displayName = "OrdinalFrame";
    return OrdinalFrame;
}(React.Component));
exports.default = OrdinalFrame;
//# sourceMappingURL=OrdinalFrame.js.map