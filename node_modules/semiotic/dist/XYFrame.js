"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var d3_scale_1 = require("d3-scale");
var axis_1 = require("./visualizationLayerBehavior/axis");
// components
var Axis_1 = require("./Axis");
var DownloadButton_1 = require("./DownloadButton");
var Frame_1 = require("./Frame");
var xyframeRules_1 = require("./annotationRules/xyframeRules");
var baseRules_1 = require("./annotationRules/baseRules");
var general_1 = require("./visualizationLayerBehavior/general");
var lineDrawing_1 = require("./svg/lineDrawing");
var AnnotationCallout_1 = require("react-annotation/lib/Types/AnnotationCallout");
var frameFunctions_1 = require("./svg/frameFunctions");
var downloadDataMapping_1 = require("./downloadDataMapping");
var coordinateNames_1 = require("./constants/coordinateNames");
var dataFunctions_1 = require("./data/dataFunctions");
var unflowedFunctions_1 = require("./data/unflowedFunctions");
var multiAccessorUtils_1 = require("./data/multiAccessorUtils");
var frame_props_1 = require("./constants/frame_props");
var SpanOrDiv_1 = require("./SpanOrDiv");
var naturalLanguageLineType = {
    line: { items: "line", chart: "line chart" },
    area: { items: "summary", chart: "summary chart" },
    summary: { items: "summary", chart: "summary chart" },
    cumulative: { items: "line", chart: "cumulative chart" },
    "cumulative-reverse": { items: "line", chart: "cumulative chart" },
    linepercent: { items: "line", chart: "line chart" },
    stackedarea: { items: "stacked area", chart: "stacked area chart" },
    "stackedarea-invert": { items: "stacked area", chart: "stacked area chart" },
    stackedpercent: { items: "stacked area", chart: "stacked area chart" },
    "stackedpercent-invert": {
        items: "stacked area",
        chart: "stacked area chart"
    },
    bumparea: { items: "ranked area", chart: "ranked area chart" },
    "bumparea-invert": { items: "ranked area", chart: "ranked area chart" },
    bumpline: { items: "ranked line", chart: "ranked line chart" },
    difference: {
        items: "line",
        chart: "difference chart"
    }
};
var emptyObjectReturnFunction = function () { return ({}); };
var emptyStringReturnFunction = function () { return ""; };
var xyframeKey = "";
var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
for (var i = 32; i > 0; --i)
    xyframeKey += chars[Math.floor(Math.random() * chars.length)];
var projectedCoordinateNames = {
    y: coordinateNames_1.projectedY,
    x: coordinateNames_1.projectedX,
    yMiddle: coordinateNames_1.projectedYMiddle,
    yTop: coordinateNames_1.projectedYTop,
    yBottom: coordinateNames_1.projectedYBottom,
    xMiddle: coordinateNames_1.projectedXMiddle,
    xTop: coordinateNames_1.projectedXTop,
    xBottom: coordinateNames_1.projectedXBottom
};
function mapParentsToPoints(fullDataset) {
    return fullDataset.map(function (d) {
        if (d.parentLine) {
            return Object.assign({}, d.parentLine, d);
        }
        if (d.parentSummary) {
            return Object.assign({}, d.parentSummary, d);
        }
        return d;
    });
}
var XYFrame = /** @class */ (function (_super) {
    __extends(XYFrame, _super);
    function XYFrame() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            size: [500, 500],
            dataVersion: undefined,
            lineData: undefined,
            pointData: undefined,
            summaryData: undefined,
            projectedLines: undefined,
            projectedPoints: undefined,
            projectedSummaries: undefined,
            fullDataset: [],
            adjustedPosition: [0, 0],
            adjustedSize: [500, 500],
            backgroundGraphics: null,
            foregroundGraphics: null,
            axesData: undefined,
            axes: undefined,
            axesTickLines: undefined,
            renderNumber: 0,
            margin: { top: 0, bottom: 0, left: 0, right: 0 },
            calculatedXExtent: [0, 0],
            calculatedYExtent: [0, 0],
            xAccessor: [function (d) { return d.x; }],
            yAccessor: [function (d) { return d.y; }],
            xExtent: [0, 0],
            yExtent: [0, 0],
            areaAnnotations: [],
            xScale: d3_scale_1.scaleLinear(),
            yScale: d3_scale_1.scaleLinear(),
            title: null,
            legendSettings: undefined,
            xyFrameRender: {},
            canvasDrawing: [],
            annotatedSettings: {
                xAccessor: undefined,
                yAccessor: undefined,
                summaryDataAccessor: undefined,
                lineDataAccessor: undefined,
                renderKeyFn: undefined,
                lineType: undefined,
                summaryType: undefined,
                lineIDAccessor: undefined,
                summaries: undefined,
                lines: undefined,
                title: undefined,
                xExtent: undefined,
                yExtent: undefined
            },
            overlay: undefined
        };
        _this.calculateXYFrame = function (currentProps, updateData) {
            var _a, _b, _c, _d;
            var legend = currentProps.legend, lines = currentProps.lines, lineClass = currentProps.lineClass, pointStyle = currentProps.pointStyle, pointRenderMode = currentProps.pointRenderMode, pointClass = currentProps.pointClass, areaClass = currentProps.areaClass, _e = currentProps.summaryClass, summaryClass = _e === void 0 ? areaClass : _e, canvasLines = currentProps.canvasLines, canvasPoints = currentProps.canvasPoints, canvasAreas = currentProps.canvasAreas, _f = currentProps.canvasSummaries, canvasSummaries = _f === void 0 ? canvasAreas : _f, defined = currentProps.defined, size = currentProps.size, renderKey = currentProps.renderKey, lineType = currentProps.lineType, areaType = currentProps.areaType, _g = currentProps.summaryType, summaryType = _g === void 0 ? areaType : _g, customLineMark = currentProps.customLineMark, customPointMark = currentProps.customPointMark, customAreaMark = currentProps.customAreaMark, _h = currentProps.customSummaryMark, customSummaryMark = _h === void 0 ? customAreaMark : _h, areaStyle = currentProps.areaStyle, _j = currentProps.summaryStyle, summaryStyle = _j === void 0 ? areaStyle : _j, areaRenderMode = currentProps.areaRenderMode, _k = currentProps.summaryRenderMode, summaryRenderMode = _k === void 0 ? areaRenderMode : _k, lineStyle = currentProps.lineStyle, lineRenderMode = currentProps.lineRenderMode, baseXExtent = currentProps.xExtent, baseYExtent = currentProps.yExtent, title = currentProps.title, _l = currentProps.xScaleType, xScaleType = _l === void 0 ? d3_scale_1.scaleLinear() : _l, _m = currentProps.yScaleType, yScaleType = _m === void 0 ? d3_scale_1.scaleLinear() : _m, lineIDAccessor = currentProps.lineIDAccessor, invertX = currentProps.invertX, invertY = currentProps.invertY, showLinePoints = currentProps.showLinePoints, showSummaryPoints = currentProps.showSummaryPoints, points = currentProps.points, areas = currentProps.areas, lineDataAccessor = currentProps.lineDataAccessor, areaDataAccessor = currentProps.areaDataAccessor, _o = currentProps.summaryDataAccessor, summaryDataAccessor = _o === void 0 ? areaDataAccessor : _o, yAccessor = currentProps.yAccessor, xAccessor = currentProps.xAccessor, useSummariesAsInteractionLayer = currentProps.useSummariesAsInteractionLayer, _p = currentProps.useAreasAsInteractionLayer, useAreasAsInteractionLayer = _p === void 0 ? useSummariesAsInteractionLayer : _p, baseMarkProps = currentProps.baseMarkProps;
            var projectedLines = currentProps.projectedLines, projectedPoints = currentProps.projectedPoints, _q = currentProps.projectedSummaries, projectedSummaries = _q === void 0 ? currentProps.projectedAreas : _q, _r = currentProps.summaries, summaries = _r === void 0 ? areas : _r, fullDataset = currentProps.fullDataset;
            if (summaryType && points && !summaries) {
                summaries = [{ coordinates: points }];
            }
            var annotatedSettings = {
                xAccessor: dataFunctions_1.stringToArrayFn(xAccessor, function (d) { return d[0]; }),
                yAccessor: dataFunctions_1.stringToArrayFn(yAccessor, function (d) { return d[1]; }),
                summaryDataAccessor: dataFunctions_1.stringToArrayFn(summaryDataAccessor, function (d) { return (Array.isArray(d) ? d : d.coordinates); }),
                lineDataAccessor: dataFunctions_1.stringToArrayFn(lineDataAccessor, function (d) { return (Array.isArray(d) ? d : d.coordinates); }),
                renderKeyFn: dataFunctions_1.stringToFn(renderKey, function (d, i) { return "line-" + i; }, true),
                lineType: frameFunctions_1.objectifyType(lineType),
                summaryType: frameFunctions_1.objectifyType(summaryType),
                lineIDAccessor: dataFunctions_1.stringToFn(lineIDAccessor, function (l) { return l.semioticLineID; }),
                summaries: !summaries || (Array.isArray(summaries) && summaries.length === 0)
                    ? undefined
                    : !Array.isArray(summaries)
                        ? [summaries]
                        : !summaryDataAccessor && !summaries[0].coordinates
                            ? [{ coordinates: summaries }]
                            : summaries,
                lines: !lines || (Array.isArray(lines) && lines.length === 0)
                    ? undefined
                    : !Array.isArray(lines)
                        ? [lines]
                        : !lineDataAccessor && !lines[0].coordinates
                            ? [{ coordinates: lines }]
                            : lines,
                title: typeof title === "object" &&
                    !React.isValidElement(title) &&
                    title !== null
                    ? title
                    : { title: title, orient: "top" },
                xExtent: Array.isArray(baseXExtent)
                    ? baseXExtent
                    : !baseXExtent
                        ? undefined
                        : baseXExtent.extent,
                yExtent: Array.isArray(baseYExtent)
                    ? baseYExtent
                    : !baseYExtent
                        ? undefined
                        : baseYExtent.extent
            };
            annotatedSettings.lineType.simpleLine =
                annotatedSettings.lineType.type === "line" &&
                    !annotatedSettings.lineType.y1 &&
                    annotatedSettings.lineType.simpleLine !== false;
            if (annotatedSettings.lineType.type === "area") {
                annotatedSettings.lineType.y1 = function () { return 0; };
            }
            var summaryStyleFn = dataFunctions_1.stringToFn(summaryStyle, emptyObjectReturnFunction, true);
            var summaryClassFn = dataFunctions_1.stringToFn(summaryClass, emptyStringReturnFunction, true);
            var summaryRenderModeFn = dataFunctions_1.stringToFn(summaryRenderMode, undefined, true);
            var margin = frameFunctions_1.calculateMargin({
                margin: currentProps.margin,
                axes: currentProps.axes,
                title: annotatedSettings.title
            });
            var _s = frameFunctions_1.adjustedPositionSize({
                size: currentProps.size,
                margin: margin
            }), adjustedPosition = _s.adjustedPosition, adjustedSize = _s.adjustedSize;
            var calculatedXExtent = [], calculatedYExtent = [], yExtent, xExtent, xExtentSettings, yExtentSettings;
            if (typeof baseXExtent === "object") {
                xExtentSettings = baseXExtent;
            }
            else {
                xExtentSettings = { extent: baseXExtent };
            }
            if (typeof baseYExtent === "object") {
                yExtentSettings = baseYExtent;
            }
            else {
                yExtentSettings = { extent: baseYExtent };
            }
            var xScale, yScale;
            if (updateData ||
                (currentProps.dataVersion &&
                    currentProps.dataVersion !== _this.state.dataVersion)) {
                //This will always fire at this point because xExtent/yExtent are just defined up there so revisit this logic
                if (!xExtent ||
                    !yExtent ||
                    !fullDataset ||
                    (!projectedLines && !projectedPoints && !projectedSummaries)) {
                    ;
                    (_a = dataFunctions_1.calculateDataExtent({
                        lineDataAccessor: annotatedSettings.lineDataAccessor,
                        summaryDataAccessor: annotatedSettings.summaryDataAccessor,
                        xAccessor: annotatedSettings.xAccessor,
                        yAccessor: annotatedSettings.yAccessor,
                        lineType: annotatedSettings.lineType,
                        summaryType: annotatedSettings.summaryType,
                        summaries: annotatedSettings.summaries,
                        points: points,
                        lines: annotatedSettings.lines,
                        showLinePoints: showLinePoints,
                        showSummaryPoints: showSummaryPoints,
                        xExtent: baseXExtent,
                        yExtent: baseYExtent,
                        invertX: invertX,
                        invertY: invertY,
                        adjustedSize: adjustedSize,
                        margin: margin,
                        baseMarkProps: baseMarkProps,
                        summaryStyleFn: summaryStyleFn,
                        summaryClassFn: summaryClassFn,
                        summaryRenderModeFn: summaryRenderModeFn,
                        chartSize: size,
                        xScaleType: xScaleType,
                        yScaleType: yScaleType,
                        defined: defined
                    }), xExtent = _a.xExtent, yExtent = _a.yExtent, projectedLines = _a.projectedLines, projectedPoints = _a.projectedPoints, projectedSummaries = _a.projectedSummaries, fullDataset = _a.fullDataset, calculatedXExtent = _a.calculatedXExtent, calculatedYExtent = _a.calculatedYExtent);
                }
                ;
                (_b = _this.screenScales({
                    xExtent: xExtent,
                    yExtent: yExtent,
                    adjustedSize: adjustedSize,
                    xScaleType: xScaleType,
                    yScaleType: yScaleType
                }), xScale = _b.xScale, yScale = _b.yScale);
            }
            else {
                ;
                (_c = _this.state, xExtent = _c.xExtent, yExtent = _c.yExtent, projectedLines = _c.projectedLines, projectedPoints = _c.projectedPoints, projectedSummaries = _c.projectedSummaries, fullDataset = _c.fullDataset, calculatedXExtent = _c.calculatedXExtent, calculatedYExtent = _c.calculatedYExtent);
                if (adjustedSize[0] === _this.state.adjustedSize[0] &&
                    adjustedSize[1] === _this.state.adjustedSize[1]) {
                    xScale = _this.state.xScale;
                    yScale = _this.state.yScale;
                }
                else {
                    ;
                    (_d = _this.screenScales({
                        xExtent: xExtent,
                        yExtent: yExtent,
                        adjustedSize: adjustedSize,
                        xScaleType: xScaleType,
                        yScaleType: yScaleType
                    }), xScale = _d.xScale, yScale = _d.yScale);
                }
            }
            xExtent =
                Array.isArray(xExtentSettings.extent) &&
                    xExtentSettings.extent.length === 2
                    ? xExtentSettings.extent
                    : xExtent;
            yExtent =
                Array.isArray(yExtentSettings.extent) &&
                    yExtentSettings.extent.length === 2
                    ? yExtentSettings.extent
                    : yExtent;
            var canvasDrawing = [];
            var axes;
            var axesTickLines;
            var existingBaselines = {};
            if (currentProps.axes) {
                axesTickLines = [];
                axes = currentProps.axes.map(function (d, i) {
                    var axisClassname = d.className || "";
                    axisClassname += " axis";
                    var axisScale = yScale;
                    if (existingBaselines[d.orient]) {
                        d.baseline = d.baseline || false;
                    }
                    existingBaselines[d.orient] = true;
                    if (d.orient === "top" || d.orient === "bottom") {
                        axisClassname += " x";
                        axisScale = xScale;
                    }
                    else {
                        axisClassname += " y";
                    }
                    axisClassname += " " + d.orient;
                    var tickValues;
                    if (d.tickValues && Array.isArray(d.tickValues)) {
                        tickValues = d.tickValues;
                    }
                    else if (d.tickValues instanceof Function) {
                        //otherwise assume a function
                        tickValues = d.tickValues(fullDataset, currentProps.size, axisScale);
                    }
                    var axisSize = [adjustedSize[0], adjustedSize[1]];
                    var axisParts = axis_1.axisPieces({
                        padding: d.padding,
                        tickValues: tickValues,
                        scale: axisScale,
                        ticks: d.ticks,
                        orient: d.orient,
                        size: axisSize,
                        footer: d.footer,
                        tickSize: d.tickSize
                    });
                    var axisTickLines = (React.createElement("g", { key: "axes-tick-lines-" + i, className: "axis " + axisClassname }, axis_1.axisLines({
                        axisParts: axisParts,
                        orient: d.orient,
                        tickLineGenerator: d.tickLineGenerator,
                        baseMarkProps: baseMarkProps,
                        className: axisClassname
                    })));
                    axesTickLines.push(axisTickLines);
                    return (React.createElement(Axis_1.default, { label: d.label, axisParts: axisParts, key: d.key || "axis-" + i, orient: d.orient, size: axisSize, margin: margin, ticks: d.ticks, tickSize: d.tickSize, tickFormat: d.tickFormat, tickValues: tickValues, scale: axisScale, className: axisClassname, padding: d.padding, rotate: d.rotate, annotationFunction: d.axisAnnotationFunction, glyphFunction: d.glyphFunction, baseline: d.baseline, dynamicLabelPosition: d.dynamicLabelPosition, center: d.center, xyPoints: fullDataset, marginalSummaryType: d.marginalSummaryType }));
                });
            }
            var legendSettings;
            if (legend) {
                legendSettings = legend === true ? {} : legend;
                if (projectedLines && !legendSettings.legendGroups) {
                    var typeString = annotatedSettings.lineType.type;
                    var type = typeof typeString === "string" &&
                        ["stackedarea", "stackedpercent", "bumparea"].indexOf(typeString) ===
                            -1
                        ? "line"
                        : "fill";
                    var legendGroups = [
                        {
                            styleFn: currentProps.lineStyle,
                            type: type,
                            items: projectedLines.map(function (d) {
                                return Object.assign({ label: annotatedSettings.lineIDAccessor(d) }, d);
                            })
                        }
                    ];
                    legendSettings.legendGroups = legendGroups;
                }
            }
            var areaAnnotations = [];
            if (annotatedSettings.summaryType.label && projectedSummaries) {
                projectedSummaries.forEach(function (d, i) {
                    if (d.bounds) {
                        var bounds = Array.isArray(d.bounds) ? d.bounds : [d.bounds];
                        bounds.forEach(function (labelBounds) {
                            var label = typeof annotatedSettings.summaryType.label === "function"
                                ? annotatedSettings.summaryType.label(d)
                                : annotatedSettings.summaryType.label;
                            if (label && label !== null) {
                                var labelPosition = label.position || "center";
                                var labelCenter = [
                                    xScale(labelBounds[labelPosition][0]),
                                    yScale(labelBounds[labelPosition][1])
                                ] || [xScale(d._xyfCoordinates[0]), yScale(d._xyfCoordinates[1])];
                                var labelContent = label.content || (function (p) { return p.value || p.id || i; });
                                areaAnnotations.push({
                                    x: labelCenter[0],
                                    y: labelCenter[1],
                                    dx: label.dx,
                                    dy: label.dy,
                                    className: label.className,
                                    type: label.type || AnnotationCallout_1.default,
                                    note: label.note || { title: labelContent(d) },
                                    subject: label.subject || { text: labelContent(d) },
                                    connector: label.connector
                                });
                            }
                        });
                    }
                });
            }
            var lineAriaLabel = annotatedSettings.lineType.type !== undefined &&
                typeof annotatedSettings.lineType.type === "string" &&
                naturalLanguageLineType[annotatedSettings.lineType.type];
            var xyFrameRender = {
                lines: {
                    accessibleTransform: function (data, i) { return (__assign({}, data[i].data[data[i].data.length - 1], { type: "frame-hover" })); },
                    data: projectedLines,
                    styleFn: dataFunctions_1.stringToFn(lineStyle, emptyObjectReturnFunction, true),
                    classFn: dataFunctions_1.stringToFn(lineClass, emptyStringReturnFunction, true),
                    renderMode: dataFunctions_1.stringToFn(lineRenderMode, undefined, true),
                    canvasRender: dataFunctions_1.stringToFn(canvasLines, undefined, true),
                    customMark: customLineMark,
                    type: annotatedSettings.lineType,
                    defined: defined,
                    renderKeyFn: annotatedSettings.renderKeyFn,
                    ariaLabel: lineAriaLabel,
                    axesData: currentProps.axes,
                    behavior: general_1.createLines
                },
                summaries: {
                    accessibleTransform: function (data, i) { return (__assign({}, data[i], { type: "frame-hover" })); },
                    data: projectedSummaries,
                    styleFn: summaryStyleFn,
                    classFn: summaryClassFn,
                    renderMode: summaryRenderModeFn,
                    canvasRender: dataFunctions_1.stringToFn(canvasSummaries, undefined, true),
                    customMark: customSummaryMark,
                    type: annotatedSettings.summaryType,
                    renderKeyFn: annotatedSettings.renderKeyFn,
                    behavior: general_1.createSummaries
                },
                points: {
                    accessibleTransform: function (data, i) { return (__assign({ type: "frame-hover" }, (data[i].data || data[i]))); },
                    data: projectedPoints,
                    styleFn: dataFunctions_1.stringToFn(pointStyle, emptyObjectReturnFunction, true),
                    classFn: dataFunctions_1.stringToFn(pointClass, emptyStringReturnFunction, true),
                    renderMode: dataFunctions_1.stringToFn(pointRenderMode, undefined, true),
                    canvasRender: dataFunctions_1.stringToFn(canvasPoints, undefined, true),
                    customMark: customPointMark,
                    renderKeyFn: annotatedSettings.renderKeyFn,
                    showLinePoints: showLinePoints,
                    behavior: general_1.createPoints
                }
            };
            if (xExtentSettings.onChange &&
                _this.state.calculatedXExtent.join(",") !== calculatedXExtent.join(",")) {
                xExtentSettings.onChange(calculatedXExtent);
            }
            if (yExtentSettings.onChange &&
                _this.state.calculatedYExtent.join(",") !== calculatedYExtent.join(",")) {
                yExtentSettings.onChange(calculatedYExtent);
            }
            var overlay = undefined;
            if (useAreasAsInteractionLayer && projectedSummaries) {
                overlay = general_1.createSummaries({
                    xScale: xScale,
                    yScale: yScale,
                    data: projectedSummaries
                }).map(function (m, i) { return (__assign({}, m.props, { style: { fillOpacity: 0 }, overlayData: projectedSummaries && projectedSummaries[i] // luckily createSummaries is a map fn
                 })); });
            }
            _this.setState({
                lineData: currentProps.lines,
                pointData: currentProps.points,
                summaryData: currentProps.summaries || currentProps.areas,
                dataVersion: currentProps.dataVersion,
                projectedLines: projectedLines,
                projectedPoints: projectedPoints,
                projectedSummaries: projectedSummaries,
                canvasDrawing: canvasDrawing,
                fullDataset: fullDataset,
                adjustedPosition: adjustedPosition,
                adjustedSize: adjustedSize,
                backgroundGraphics: currentProps.backgroundGraphics,
                foregroundGraphics: currentProps.foregroundGraphics,
                axesData: currentProps.axes,
                axes: axes,
                axesTickLines: axesTickLines,
                renderNumber: _this.state.renderNumber + 1,
                xScale: xScale,
                yScale: yScale,
                xAccessor: annotatedSettings.xAccessor,
                yAccessor: annotatedSettings.yAccessor,
                xExtent: [
                    xExtent[0] === undefined ? calculatedXExtent[0] : xExtent[0],
                    xExtent[1] === undefined ? calculatedXExtent[1] : xExtent[1]
                ],
                yExtent: [
                    yExtent[0] === undefined ? calculatedYExtent[0] : yExtent[0],
                    yExtent[1] === undefined ? calculatedYExtent[1] : yExtent[1]
                ],
                calculatedXExtent: calculatedXExtent,
                calculatedYExtent: calculatedYExtent,
                margin: margin,
                legendSettings: legendSettings,
                areaAnnotations: areaAnnotations,
                xyFrameRender: xyFrameRender,
                size: size,
                annotatedSettings: annotatedSettings,
                overlay: overlay
            });
        };
        _this.defaultXYSVGRule = function (_a) {
            var baseD = _a.d, i = _a.i, annotationLayer = _a.annotationLayer, lines = _a.lines, summaries = _a.summaries, points = _a.points;
            var showLinePoints = _this.props.showLinePoints;
            var _b = _this.state, xyFrameRender = _b.xyFrameRender, xScale = _b.xScale, yScale = _b.yScale, xAccessor = _b.xAccessor, yAccessor = _b.yAccessor;
            var screenCoordinates = [];
            var idAccessor = _this.state.annotatedSettings.lineIDAccessor;
            if (baseD.type === "highlight") {
                return xyframeRules_1.svgHighlight({
                    d: baseD,
                    i: i,
                    idAccessor: idAccessor,
                    lines: lines,
                    summaries: summaries,
                    points: points,
                    xScale: xScale,
                    yScale: yScale,
                    xyFrameRender: xyFrameRender
                });
            }
            var d = baseD.coordinates
                ? baseD
                : lineDrawing_1.findPointByID({
                    point: baseD,
                    idAccessor: idAccessor,
                    lines: lines,
                    xScale: xScale,
                    projectedX: coordinateNames_1.projectedX,
                    xAccessor: xAccessor
                });
            if (!d)
                return null;
            var margin = frameFunctions_1.calculateMargin({
                margin: _this.props.margin,
                axes: _this.props.axes,
                title: _this.state.annotatedSettings.title
            });
            var _c = frameFunctions_1.adjustedPositionSize({
                size: _this.props.size,
                margin: margin
            }), adjustedPosition = _c.adjustedPosition, adjustedSize = _c.adjustedSize;
            if (!d.coordinates && !d.bounds) {
                screenCoordinates = [
                    lineDrawing_1.relativeX({
                        point: d,
                        projectedXMiddle: coordinateNames_1.projectedXMiddle,
                        projectedX: coordinateNames_1.projectedX,
                        xAccessor: xAccessor,
                        xScale: xScale
                    }) || 0,
                    lineDrawing_1.relativeY({
                        point: d,
                        projectedYMiddle: coordinateNames_1.projectedYMiddle,
                        projectedY: coordinateNames_1.projectedY,
                        yAccessor: yAccessor,
                        yScale: yScale,
                        showLinePoints: showLinePoints
                    }) || 0
                ];
            }
            else if (!d.bounds) {
                screenCoordinates = d.coordinates.reduce(function (coords, p) {
                    var xCoordinate = lineDrawing_1.relativeX({
                        point: p,
                        projectedXMiddle: coordinateNames_1.projectedXMiddle,
                        projectedX: coordinateNames_1.projectedX,
                        xAccessor: xAccessor,
                        xScale: xScale
                    });
                    var yCoordinate = lineDrawing_1.relativeY({
                        point: p,
                        projectedYMiddle: coordinateNames_1.projectedYMiddle,
                        projectedY: coordinateNames_1.projectedY,
                        yAccessor: yAccessor,
                        yScale: yScale
                    });
                    if (Array.isArray(yCoordinate)) {
                        return __spread(coords, [
                            [xCoordinate, Math.min.apply(Math, __spread(yCoordinate))],
                            [xCoordinate, Math.max.apply(Math, __spread(yCoordinate))]
                        ]);
                    }
                    else if (Array.isArray(xCoordinate)) {
                        return __spread(coords, [
                            [Math.min.apply(Math, __spread(xCoordinate)), yCoordinate],
                            [Math.max.apply(Math, __spread(xCoordinate)), yCoordinate]
                        ]);
                    }
                    else {
                        return __spread(coords, [[xCoordinate, yCoordinate]]);
                    }
                }, []);
            }
            var voronoiHover = annotationLayer.voronoiHover;
            var customSVG = _this.props.svgAnnotationRules &&
                _this.props.svgAnnotationRules({
                    d: d,
                    i: i,
                    screenCoordinates: screenCoordinates,
                    xScale: xScale,
                    yScale: yScale,
                    xAccessor: xAccessor,
                    yAccessor: yAccessor,
                    xyFrameProps: _this.props,
                    xyFrameState: _this.state,
                    summaries: summaries,
                    points: points,
                    lines: lines,
                    voronoiHover: voronoiHover,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer
                });
            if (_this.props.svgAnnotationRules !== undefined && customSVG !== null) {
                return customSVG;
            }
            else if (d.type === "desaturation-layer") {
                return baseRules_1.desaturationLayer({
                    style: d.style instanceof Function ? d.style(d, i) : d.style,
                    size: adjustedSize,
                    i: i,
                    key: d.key
                });
            }
            else if (d.type === "xy" || d.type === "frame-hover") {
                return xyframeRules_1.svgXYAnnotation({ d: d, i: i, screenCoordinates: screenCoordinates });
            }
            else if (d.type === "react-annotation" || typeof d.type === "function") {
                return xyframeRules_1.basicReactAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "enclose") {
                return xyframeRules_1.svgEncloseAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "enclose-rect") {
                return xyframeRules_1.svgRectEncloseAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "enclose-hull") {
                return xyframeRules_1.svgHullEncloseAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
            }
            else if (d.type === "x") {
                return xyframeRules_1.svgXAnnotation({
                    d: d,
                    screenCoordinates: screenCoordinates,
                    i: i,
                    adjustedSize: adjustedSize
                });
            }
            else if (d.type === "y") {
                return xyframeRules_1.svgYAnnotation({
                    d: d,
                    screenCoordinates: screenCoordinates,
                    i: i,
                    adjustedSize: adjustedSize,
                    adjustedPosition: adjustedPosition
                });
            }
            else if (d.type === "bounds") {
                return xyframeRules_1.svgBoundsAnnotation({
                    d: d,
                    i: i,
                    adjustedSize: adjustedSize,
                    xAccessor: xAccessor,
                    yAccessor: yAccessor,
                    xScale: xScale,
                    yScale: yScale
                });
            }
            else if (d.type === "line") {
                return xyframeRules_1.svgLineAnnotation({ d: d, i: i, screenCoordinates: screenCoordinates });
            }
            else if (d.type === "area") {
                return xyframeRules_1.svgAreaAnnotation({
                    d: d,
                    i: i,
                    xScale: xScale,
                    xAccessor: xAccessor,
                    yScale: yScale,
                    yAccessor: yAccessor,
                    annotationLayer: annotationLayer
                });
            }
            else if (d.type === "horizontal-points") {
                return xyframeRules_1.svgHorizontalPointsAnnotation({
                    d: d,
                    lines: lines.data,
                    points: points.data,
                    xScale: xScale,
                    yScale: yScale,
                    pointStyle: points.styleFn
                });
            }
            else if (d.type === "vertical-points") {
                return xyframeRules_1.svgVerticalPointsAnnotation({
                    d: d,
                    lines: lines.data,
                    points: points.data,
                    xScale: xScale,
                    yScale: yScale,
                    pointStyle: points.styleFn
                });
            }
            return null;
        };
        _this.defaultXYHTMLRule = function (_a) {
            var baseD = _a.d, i = _a.i, lines = _a.lines, summaries = _a.summaries, points = _a.points, annotationLayer = _a.annotationLayer;
            var xAccessor = _this.state.xAccessor;
            var yAccessor = _this.state.yAccessor;
            var showLinePoints = _this.props.showLinePoints;
            var xScale = _this.state.xScale;
            var yScale = _this.state.yScale;
            var voronoiHover = annotationLayer.voronoiHover;
            var screenCoordinates = [];
            var useSpans = _this.props.useSpans;
            var idAccessor = _this.state.annotatedSettings.lineIDAccessor;
            var d = lineDrawing_1.findPointByID({
                point: baseD,
                idAccessor: idAccessor,
                lines: lines,
                xScale: xScale,
                projectedX: coordinateNames_1.projectedX,
                xAccessor: xAccessor
            });
            if (!d) {
                return null;
            }
            var xCoord = d[coordinateNames_1.projectedXMiddle] ||
                d[coordinateNames_1.projectedX] ||
                multiAccessorUtils_1.findFirstAccessorValue(xAccessor, d);
            var yCoord = d[coordinateNames_1.projectedYMiddle] ||
                d[coordinateNames_1.projectedY] ||
                multiAccessorUtils_1.findFirstAccessorValue(yAccessor, d);
            var xString = xCoord && xCoord.toString ? xCoord.toString() : xCoord;
            var yString = yCoord && yCoord.toString ? yCoord.toString() : yCoord;
            var margin = frameFunctions_1.calculateMargin({
                margin: _this.props.margin,
                axes: _this.props.axes,
                title: _this.state.annotatedSettings.title
            });
            var _b = frameFunctions_1.adjustedPositionSize({
                size: _this.props.size,
                margin: margin
            }), adjustedPosition = _b.adjustedPosition, adjustedSize = _b.adjustedSize;
            if (!d.coordinates) {
                screenCoordinates = [
                    xScale(xCoord) || 0,
                    lineDrawing_1.relativeY({
                        point: d,
                        projectedYMiddle: coordinateNames_1.projectedYMiddle,
                        projectedY: coordinateNames_1.projectedY,
                        showLinePoints: showLinePoints,
                        yAccessor: yAccessor,
                        yScale: yScale
                    }) || 0
                ];
            }
            else {
                screenCoordinates = d.coordinates.map(function (p) {
                    var foundP = lineDrawing_1.findPointByID({
                        point: __assign({ x: 0, y: 0 }, p),
                        idAccessor: idAccessor,
                        lines: lines,
                        xScale: xScale,
                        projectedX: coordinateNames_1.projectedX,
                        xAccessor: xAccessor
                    });
                    return [
                        (xScale(multiAccessorUtils_1.findFirstAccessorValue(xAccessor, d)) || 0) +
                            adjustedPosition[0],
                        (lineDrawing_1.relativeY({
                            point: foundP,
                            projectedYMiddle: coordinateNames_1.projectedYMiddle,
                            projectedY: coordinateNames_1.projectedY,
                            yAccessor: yAccessor,
                            yScale: yScale
                        }) || 0) + adjustedPosition[1]
                    ];
                });
            }
            var customAnnotation = _this.props.htmlAnnotationRules &&
                _this.props.htmlAnnotationRules({
                    d: d,
                    i: i,
                    screenCoordinates: screenCoordinates,
                    xScale: xScale,
                    yScale: yScale,
                    xAccessor: xAccessor,
                    yAccessor: yAccessor,
                    xyFrameProps: _this.props,
                    xyFrameState: _this.state,
                    summaries: summaries,
                    points: points,
                    lines: lines,
                    voronoiHover: voronoiHover,
                    adjustedPosition: adjustedPosition,
                    adjustedSize: adjustedSize,
                    annotationLayer: annotationLayer
                });
            if (_this.props.htmlAnnotationRules && customAnnotation !== null) {
                return customAnnotation;
            }
            if (d.type === "frame-hover") {
                var content = (React.createElement(SpanOrDiv_1.default, { span: useSpans, className: "tooltip-content" },
                    React.createElement("p", { key: "html-annotation-content-1" }, xString),
                    React.createElement("p", { key: "html-annotation-content-2" }, yString),
                    d.percent ? (React.createElement("p", { key: "html-annotation-content-3" },
                        Math.floor(d.percent * 1000) / 10,
                        "%")) : null));
                if (d.type === "frame-hover" && _this.props.tooltipContent) {
                    content = _this.props.tooltipContent(d);
                }
                return xyframeRules_1.htmlTooltipAnnotation({
                    content: content,
                    screenCoordinates: screenCoordinates,
                    i: i,
                    d: d,
                    useSpans: useSpans
                });
            }
            return null;
        };
        return _this;
    }
    XYFrame.prototype.componentWillUnmount = function () {
        if (this.props.onUnmount) {
            this.props.onUnmount(this.props, this.state);
        }
    };
    XYFrame.prototype.componentWillMount = function () {
        Object.keys(this.props).forEach(function (d) {
            if (!frame_props_1.xyframeproptypes[d]) {
                if (frame_props_1.ordinalframeproptypes[d]) {
                    console.error(d + " is an OrdinalFrame prop are you sure you're using the right frame?");
                }
                else if (frame_props_1.networkframeproptypes[d]) {
                    console.error(d + " is a NetworkFrame prop are you sure you're using the right frame?");
                }
                else {
                    console.error(d + " is not a valid XYFrame prop");
                }
            }
        });
        this.calculateXYFrame(this.props, true);
    };
    XYFrame.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var _a = this.state, _b = _a.xExtent, oldXExtent = _b === void 0 ? [] : _b, _c = _a.yExtent, oldYExtent = _c === void 0 ? [] : _c, oldSize = _a.size, oldDataVersion = _a.dataVersion, lineData = _a.lineData, summaryData = _a.summaryData, pointData = _a.pointData;
        var baseNewXExtent = nextProps.xExtent, baseNewYExtent = nextProps.yExtent, newSize = nextProps.size, newDataVersion = nextProps.dataVersion, newLines = nextProps.lines, areas = nextProps.areas, _d = nextProps.summaries, newSummaries = _d === void 0 ? areas : _d, newPoints = nextProps.points;
        var newXExtent = unflowedFunctions_1.extentValue(baseNewXExtent);
        var newYExtent = unflowedFunctions_1.extentValue(baseNewYExtent);
        var extentChange = (oldXExtent[0] !== newXExtent[0] && newXExtent[0] !== undefined) ||
            (oldYExtent[0] !== newYExtent[0] && newYExtent[0] !== undefined) ||
            (oldXExtent[1] !== newXExtent[1] && newXExtent[1] !== undefined) ||
            (oldYExtent[1] !== newYExtent[1] && newYExtent[1] !== undefined);
        var lineChange = lineData !== newLines ||
            (Array.isArray(lineData) &&
                Array.isArray(newLines) &&
                !!lineData.find(function (p) { return newLines.indexOf(p) === -1; }));
        var summaryChange = summaryData !== newSummaries ||
            (Array.isArray(summaryData) &&
                Array.isArray(newSummaries) &&
                !!summaryData.find(function (p) { return newSummaries.indexOf(p) === -1; }));
        var pointChange = pointData !== newPoints ||
            (Array.isArray(pointData) &&
                Array.isArray(newPoints) &&
                !!pointData.find(function (p) { return newPoints.indexOf(p) === -1; }));
        if ((oldDataVersion && oldDataVersion !== newDataVersion) ||
            !this.state.fullDataset) {
            this.calculateXYFrame(nextProps, true);
        }
        else if (lineChange ||
            summaryChange ||
            pointChange ||
            oldSize[0] !== newSize[0] ||
            oldSize[1] !== newSize[1] ||
            extentChange ||
            (!oldDataVersion &&
                frame_props_1.xyFrameChangeProps.find(function (d) { return _this.props[d] !== nextProps[d]; }))) {
            var dataChanged = lineChange ||
                summaryChange ||
                pointChange ||
                extentChange ||
                !!frame_props_1.xyFrameDataProps.find(function (d) { return _this.props[d] !== nextProps[d]; });
            this.calculateXYFrame(nextProps, dataChanged);
        }
    };
    XYFrame.prototype.screenScales = function (_a) {
        var xExtent = _a.xExtent, yExtent = _a.yExtent, adjustedSize = _a.adjustedSize, xScaleType = _a.xScaleType, yScaleType = _a.yScaleType;
        var xDomain = [0, adjustedSize[0]];
        var yDomain = [adjustedSize[1], 0];
        var xScale = xScaleType;
        var yScale = yScaleType;
        if (xScaleType.domain) {
            xScaleType.domain(xExtent);
        }
        if (yScaleType.domain) {
            yScaleType.domain(yExtent);
        }
        xScaleType.range(xDomain);
        yScaleType.range(yDomain);
        return { xScale: xScale, yScale: yScale };
    };
    XYFrame.prototype.render = function () {
        var _a = this.props, downloadFields = _a.downloadFields, xAccessor = _a.xAccessor, yAccessor = _a.yAccessor, lines = _a.lines, points = _a.points, areas = _a.areas, _b = _a.summaries, summaries = _b === void 0 ? areas : _b, name = _a.name, download = _a.download, size = _a.size, className = _a.className, annotationSettings = _a.annotationSettings, annotations = _a.annotations, additionalDefs = _a.additionalDefs, hoverAnnotation = _a.hoverAnnotation, interaction = _a.interaction, customClickBehavior = _a.customClickBehavior, customHoverBehavior = _a.customHoverBehavior, customDoubleClickBehavior = _a.customDoubleClickBehavior, canvasPostProcess = _a.canvasPostProcess, baseMarkProps = _a.baseMarkProps, useSpans = _a.useSpans, canvasAreas = _a.canvasAreas, _c = _a.canvasSummaries, canvasSummaries = _c === void 0 ? canvasAreas : _c, canvasPoints = _a.canvasPoints, canvasLines = _a.canvasLines, afterElements = _a.afterElements, beforeElements = _a.beforeElements, renderOrder = _a.renderOrder, matte = _a.matte, frameKey = _a.frameKey, showLinePoints = _a.showLinePoints;
        var _d = this.state, backgroundGraphics = _d.backgroundGraphics, foregroundGraphics = _d.foregroundGraphics, adjustedPosition = _d.adjustedPosition, adjustedSize = _d.adjustedSize, margin = _d.margin, axes = _d.axes, axesTickLines = _d.axesTickLines, xScale = _d.xScale, yScale = _d.yScale, dataVersion = _d.dataVersion, fullDataset = _d.fullDataset, areaAnnotations = _d.areaAnnotations, legendSettings = _d.legendSettings, xyFrameRender = _d.xyFrameRender, annotatedSettings = _d.annotatedSettings, overlay = _d.overlay;
        var downloadButton;
        if (download && (points || lines)) {
            var downloadData = download === "points"
                ? mapParentsToPoints(fullDataset)
                : points || lines || summaries || areas;
            downloadButton = (React.createElement(DownloadButton_1.default, { csvName: name + "-" + new Date().toJSON(), width: Math.floor(size[0]), data: downloadDataMapping_1.xyDownloadMapping({
                    data: downloadData,
                    xAccessor: download === "points" || points
                        ? dataFunctions_1.stringToArrayFn(xAccessor)
                        : undefined,
                    yAccessor: download === "points" || points
                        ? dataFunctions_1.stringToArrayFn(yAccessor)
                        : undefined,
                    fields: downloadFields
                }) }));
        }
        return (React.createElement(Frame_1.default, { name: "xyframe", renderPipeline: xyFrameRender, adjustedPosition: adjustedPosition, size: size, projectedCoordinateNames: projectedCoordinateNames, xScale: xScale, yScale: yScale, axes: axes, axesTickLines: axesTickLines, title: annotatedSettings.title, dataVersion: dataVersion, matte: matte, className: className, adjustedSize: adjustedSize, frameKey: frameKey || xyframeKey, additionalDefs: additionalDefs, hoverAnnotation: hoverAnnotation, defaultSVGRule: this.defaultXYSVGRule, defaultHTMLRule: this.defaultXYHTMLRule, annotations: areaAnnotations.length > 0
                ? __spread(annotations, areaAnnotations) : annotations, annotationSettings: annotationSettings, legendSettings: legendSettings, projectedYMiddle: coordinateNames_1.projectedYMiddle, interaction: interaction, customClickBehavior: customClickBehavior, customHoverBehavior: customHoverBehavior, customDoubleClickBehavior: customDoubleClickBehavior, points: fullDataset, showLinePoints: typeof showLinePoints === "string" ? showLinePoints : undefined, margin: margin, backgroundGraphics: backgroundGraphics, foregroundGraphics: foregroundGraphics, beforeElements: beforeElements, afterElements: afterElements, downloadButton: downloadButton, disableContext: this.props.disableContext, canvasPostProcess: canvasPostProcess, baseMarkProps: baseMarkProps, useSpans: useSpans, canvasRendering: !!(canvasSummaries || canvasPoints || canvasLines), renderOrder: renderOrder, overlay: overlay }));
    };
    XYFrame.defaultProps = {
        annotations: [],
        foregroundGraphics: undefined,
        size: [500, 500],
        className: "",
        lineType: "line",
        name: "xyframe",
        dataVersion: undefined
    };
    XYFrame.displayName = "XYFrame";
    return XYFrame;
}(React.Component));
exports.default = XYFrame;
//# sourceMappingURL=XYFrame.js.map